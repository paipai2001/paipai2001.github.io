[{"content":"GO语言学习 day01:基础类型\nday02:函数工程管理\nday03:复合类型\nday04:oop\nday05:异常文本文件处理\nday06:并发编程\nday07:网络概述\nday08:http编程\n回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; type FuncType func(int, int) int func Add(a, b int) int { return a + b } //回调函数 函数有一个参数是函数类型 这个函数就是回调函数 //计算器 可以进行四则运算 //多态，多种形态，调用同一个接口，不同的表现，从一个接口可以实现不同表现 加减乘除 // 先有想法 后面再实现功能 //可扩展性 func Calc(a, b int, fTest FuncType) (result int) { fmt.Println(\u0026#34;Calc\u0026#34;) result = fTest(a, b) //这个函数还没有实现 //result = Add(a,b)//必须先定义才能使用 return } func main() { a := Calc(1, 1, Add) fmt.Println(\u0026#34;a = \u0026#34;, a) } 匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; //匿名函数 没有函数名字 f1 := func() { //:=自动推导类型 fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;str = \u0026#34;, str) } f1() //给一个函数类型起别名 type FuncType func() // 函数没有参数 没有返回值 var f2 FuncType f2 = f1 f2() //定义匿名函数 同时调用 func() { fmt.Println(\u0026#34;a = %d str = %s\u0026#34;, a, str) }() //后面的()代表调用这个匿名函数 // 带参数的匿名函数 f3 := func(i, j int) { fmt.Printf(\u0026#34;i = %d,j = %d\u0026#34;, i, j) } f3(10, 20) //匿名函数 有参有返回值 x, y := func(i, j int) (max, min int) { if i \u0026gt; j { max = i min = j } else { max = j min = i } return }(10, 20) fmt.Printf(\u0026#34;x = %d y = %d\\n\u0026#34;, x, y) } 闭包 不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; func() { //闭包以引用方式捕获外部变量 a = 666 str = \u0026#34;go\u0026#34; fmt.Printf(\u0026#34;a = %d, str = %s\\n\u0026#34;, a, str) }() //()代表直接调用 fmt.Printf(\u0026#34;outside:a = %d, str = %s\\n\u0026#34;, a, str) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func test01() int { var x int //没有初始化 值为0 x++ return x * x } func main() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } 1 2 3 4 5 PS D:\\go\\workspace\\demo\u0026gt; go run bibao.go 1 1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; //函数返回值是一个匿名函数 返回一个函数类型 func test02() func() int { var x int return func() int { x++ return x * x } } func main() { //返回值为一个匿名函数 所以返回一个函数类型 通过f 调用返回的匿名函数 //它不关心这些捕获了的变量和常量是否已经超出了作用域 // 所以只要闭包还在使用它 这些变量就还会存在 f := test02() fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) } func test01() int { //函数被调用时，x才分配空间，才初始化为0 var x int //没有初始化 值为0 x++ return x * x //函数调用完毕，x自动释放 } func main01() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } defer延迟调用 1 2 3 package main import \u0026#34;fmt\u0026#34; 获取命令行参数 1 2 3 4 package main import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; 工程管理 同一个目录下：\n分文件编程 必须放在src目录\n设置gopath环境变量\n同一个目录 包名必须一样\ngo env 查看go相关环境路径\n同一个目录 调用别的文件函数 直接调用即可 无需包名引用\n不同目录下：\nsrc:main.go\nsrc/calc:calc.go\n不同目录 包名不一样\n调用不同包里面的函数 格式：包名.函数名（)\n也要import “calc”\n调用别的包函数 如果函数名字开头小写 无法调用\n必须首字母大写\n变量内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int = 10 fmt.Printf(\u0026#34;a = %d\\n\u0026#34;, a) fmt.Printf(\u0026#34;\u0026amp;a = %v\\n\u0026#34;, \u0026amp;a) //保存某个变量地址 需要指针类型 *int 保存int的地址 ** int 保存 *int地址 var p *int p = \u0026amp;a //指针变量指向谁 就把谁的地址赋值给指针变量 // fmt.Printf(\u0026#34;*p = %v, a= %v\u0026#34;, *p, a) } 不要操作没有合法指向内存 值传递和地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { *a, *b = *b, *a fmt.Printf(\u0026#34;swap:a = %d,b = %d\\n\u0026#34;, *a, *b) } func main() { a, b := 10, 20 swap(\u0026amp;a, \u0026amp;b) //变量本身传递 值传递 fmt.Printf(\u0026#34;main:a = %d,b = %d\\n\u0026#34;, a, b) } 数组array 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { // 数组同一个类型的集合 var id [50]int for i := 0; i \u0026lt; len(id); i++ { id[i] = i + 1 fmt.Printf(\u0026#34;%d\\n\u0026#34;, id[i]) } } 数组基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { var a [10]int var b [5]int fmt.Printf(\u0026#34;len(a) = %d len(b) = %d\\n\u0026#34;, len(a), len(b)) // 注意数组元素个数必须是常量 // n:= 10 // var c [n]int error non-constant array boud n // 下标可以是变量或者常量 a[0] = 1 i := 1 a[i] = 2 for i := 0; i \u0026lt; len(a); i++ { a[i] = i + 1 fmt.Printf(\u0026#34;%d\u0026#34;, a[i]) } for i, data := range a { fmt.Printf(\u0026#34;a[%d] = %d\\n\u0026#34;, i, data) } } 数组初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { //声明定义同时赋值 叫初始化 // 全部初始化 var a [5]int = [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;a = \u0026#34;, a) // b := [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;b = \u0026#34;, b) // 部分初始化 没有初始化的元素 自动赋值为0 c := [5]int{1, 2, 3} fmt.Println(\u0026#34;c = \u0026#34;, c) // 指定某个元素初始化 d := [5]int{2: 10, 4: 20} fmt.Println(\u0026#34;d = \u0026#34;, d) } 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func main() { var a [3][4]int k := 0 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 4; j++ { k++ a[i][j] = k fmt.Printf(\u0026#34;a[%d][%d] = %d \u0026#34;, i, j, a[i][j]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}} fmt.Println(\u0026#34;b= \u0026#34;, b) // 部分初始化 其他值为0 c := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}, {9, 10}} fmt.Println(\u0026#34;c= \u0026#34;, c) d := [3][4]int{1:{5, 6, 7, 8}} fmt.Println(\u0026#34;d= \u0026#34;, d) } 数组比较和赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { // 支持比较 只支持==或者!= 比较是不是每个元素都一样 两个数组比较 类型必须一致 a := [5]int{1, 2, 3, 4, 5} b := [5]int{1, 2, 3, 4, 5} c := [5]int{1, 2, 3} fmt.Println(\u0026#34; a == b \u0026#34;, a == b) fmt.Println(\u0026#34;a == c \u0026#34;, a == c) // 同类型的数组可以赋值 var d [5]int d = a fmt.Println(\u0026#34;d = \u0026#34;, d) } 随机数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;rand = \u0026#34;, rand.Intn(100)) //限制在100以内 } } 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 var a [10]int n := len(a) for i := 0; i \u0026lt; n; i++ { a[i] = rand.Intn(100) fmt.Printf(\u0026#34;%d \u0026#34;, a[i]) //限制在100以内 } fmt.Printf(\u0026#34;\\n\u0026#34;) for i := 0; i \u0026lt; n-1; i++ { for j := 0; j \u0026lt; n-i-1; j++ { if a[j] \u0026gt; a[j+1] { a[j], a[j+1] = a[j+1], a[j] } } } fmt.Printf(\u0026#34;\\n排序后:\\n\u0026#34;) for i := 0; i \u0026lt; n; i++ { fmt.Printf(\u0026#34;%v \u0026#34;, a[i]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } 数组做函数参数是值拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; // 数组做函数参数 值传递 // 实参数组的每个元素给形参拷贝一份 //形参数组是实参数组的复制品 func modify(a [5]int) { a[0] = 666 fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(a) fmt.Println(\u0026#34;a = \u0026#34;, a) } 数组指针做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; //p指向实参数组a 数组指针 // *p代表指针指向内存 也就是实参a func modify(p *[5]int) { (*p)[0] = 666 fmt.Println(\u0026#34;p = \u0026#34;, *p) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(\u0026amp;a) //地址传递 fmt.Println(\u0026#34;a = \u0026#34;, a) } 切片 实现变长数组方案:需要用一个数组保存学生成绩 但是学生个数不确定\n不是真正意义的动态数组 只是一个引用类型 总是指向一个底层array\narray := [\u0026hellip;]int{10,20,30,9,0}\nslice:=array[0:3:5]\n[low:high:max]\nlow:下标起点\nhigh:下标终点\nmax:容量\n左闭右开 不包括high下标\nlen = high-low\ncap = max-low\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { a := []int{1, 2, 3, 0, 0} s := a[0:3:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) s = a[1:4:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) } 数组和切片区别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import \u0026#34;fmt\u0026#34; func main() { //自动推导类型 s1 := []int{1, 2, 3, 4} fmt.Println(\u0026#34;s1= \u0026#34;, s1) //make 格式：make(切片类型,len,cap) s2 := make([]int, 5, 10) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s2), cap(s2)) // 没有指定容量 容量和长度一样 s3 := make([]int, 5) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s3), cap(s3)) } func main01() { //切片和数组的区别 //数组[]里面的长度是一个固定的常量 数组不能修改长度 len和cap永远都是5 a := [5]int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(a), cap(a)) // 切片 []里面为空 或者为... // 切片的长度或者容量可以不固定 s := []int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) s = append(s, 11) //给切片末尾追加一个成员 fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) } 切片截取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { array := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := array[:] //[0:len(array):len(array)]不指定容量和长度一样 fmt.Println(\u0026#34;s1 = \u0026#34;, s1) fmt.Printf(\u0026#34;len(s1) = %d,cap(s1) = %d\\n\u0026#34;, len(s1), cap(s1)) //操作某个元素 和数组操作方式一样 data := array[0] fmt.Printf(\u0026#34;data=%v\\n\u0026#34;, data) s2 := array[3:6:7] //a[3] a[4] a[5] len = 6-3=3 cap = 7-3 = 4 fmt.Printf(\u0026#34;len(s2) = %d,cap(s2) = %d\\n\u0026#34;, len(s2), cap(s2)) s3 := array[:6] //从0开始 去6个元素 容量也是6 fmt.Println(\u0026#34;s3 = \u0026#34;, s3) fmt.Printf(\u0026#34;len(s3) = %d,cap(s3) = %d\\n\u0026#34;, len(s3), cap(s3)) s4 := array[3:] //从下标为3开始 到结尾 fmt.Println(\u0026#34;s4 = \u0026#34;, s4) fmt.Printf(\u0026#34;len(s4) = %d,cap(s4) = %d\\n\u0026#34;, len(s4), cap(s4)) } append函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { s1 := []int{} fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //在原切片末尾添加元素 s1 = append(s1, 1) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s1 = append(s1, 2, 3) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s2 := []int{1, 2, 3} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) s2 = append(s2, 3, 4, 5) fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } 扩容特点：\n如果超过原来的容量 通常以两倍容量扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { s := make([]int, 0, 1) oldCap := cap(s) for i := 0; i \u0026lt; 8; i++ { s = append(s, i) if newCap := cap(s); oldCap \u0026lt; newCap { fmt.Printf(\u0026#34;cap:%d=====\u0026gt;%d\\n\u0026#34;, oldCap, newCap) oldCap = newCap } } } copy使用 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { srcSlice := []int{1, 2} dstSlice := []int{6, 6, 6, 6, 6} copy(dstSlice, srcSlice) fmt.Println(\u0026#34;dst = \u0026#34;, dstSlice) } dst = [1 2 6 6 6]\n切片做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func test(s []int) { //切片做函数参数 s[0] = -1 fmt.Println(\u0026#34;test : \u0026#34;) for i, v := range s { fmt.Printf(\u0026#34;s[%d]=%d, \u0026#34;, i, v) //s[0]=-1, s[1]=1, s[2]=2, s[3]=3, s[4]=4, s[5]=5, s[6]=6, s[7]=7, s[8]=8, s[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} test(slice) fmt.Println(\u0026#34;main : \u0026#34;) for i, v := range slice { fmt.Printf(\u0026#34;slice[%d]=%d, \u0026#34;, i, v) //slice[0]=-1, slice[1]=1, slice[2]=2, slice[3]=3, slice[4]=4, slice[5]=5, slice[6]=6, slice[7]=7, slice[8]=8, slice[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } 猜数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func CreatNum(p *int) { rand.Seed(time.Now().UnixNano()) num := rand.Intn(9000) + 1000 *p = num } func GetNum(s []int, num int) { s[0] = num / 1000 s[1] = num % 1000 / 100 s[2] = num % 100 / 10 s[3] = num % 10 } func OnGame(randNum []int) { var num int for { for { fmt.Printf(\u0026#34;请输入一个四位数：\u0026#34;) fmt.Scan(\u0026amp;num) if num \u0026gt; 999 \u0026amp;\u0026amp; num \u0026lt; 10000 { break } fmt.Printf(\u0026#34;输入数字不是四位数 请重新输入：\u0026#34;) } fmt.Println(\u0026#34;num = \u0026#34;, num) keySlice := make([]int, 4) GetNum(keySlice, num) fmt.Println(\u0026#34;keyslice = \u0026#34;, keySlice) n := 0 for i := 0; i \u0026lt; 4; i++ { if randNum[i] \u0026lt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 大了一点\\n\u0026#34;, i+1) } else if randNum[i] \u0026gt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 小了一点\\n\u0026#34;, i+1) } else { fmt.Printf(\u0026#34;第%d位 猜对了 要再接再厉\\n\u0026#34;, i+1) n++ } } if n == 4 { fmt.Println(\u0026#34;全部猜对啦！\u0026#34;) break } } } func main() { var randNum int //产生一个4位的随机数 CreatNum(\u0026amp;randNum) fmt.Println(\u0026#34;randNum: \u0026#34;, randNum) randSlice := make([]int, 4) GetNum(randSlice, randNum) fmt.Println(\u0026#34;randSlice = \u0026#34;, randSlice) OnGame(randSlice) //游戏 } map 键值对 字典\nmap[int]string{\n110:\u0026ldquo;string\u0026rdquo;\n111:\u0026ldquo;void\u0026rdquo;\n}\n注意是无序的 返回顺序不一定\n键值唯一 切片不能做键值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string var m1 map[int]string fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //对于map只有len,没有cap fmt.Println(\u0026#34;len = \u0026#34;, len(m1)) //可以通过make创建 可以指定长度 m2 := make(map[int]string) fmt.Println(\u0026#34;m2 = \u0026#34;, m2) fmt.Println(\u0026#34;len = \u0026#34;, len(m2)) //这个指定的长度其实是容量 m3 := make(map[int]string, 10) m3[1] = \u0026#34;mike\u0026#34; m3[2] = \u0026#34;go\u0026#34; m3[3] = \u0026#34;c++\u0026#34; fmt.Println(\u0026#34;m3 = \u0026#34;, m3) fmt.Println(\u0026#34;len = \u0026#34;, len(m3)) //初始化 键值必须是唯一的 m4 := map[int]string{1: \u0026#34;mike\u0026#34;} fmt.Println(\u0026#34;m4 = \u0026#34;, m4) fmt.Println(\u0026#34;len = \u0026#34;, len(m4)) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string m1 := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;} fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //不存在直接加上 m1[3] = \u0026#34;c++\u0026#34; //存在就修改 m1[1] = \u0026#34;go\u0026#34; fmt.Println(\u0026#34;now:m1 = \u0026#34;, m1) m := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;, 3: \u0026#34;go\u0026#34;} // 第一个返回值是key 第二个返回值是value 遍历结果是无序的 for key, value := range m { fmt.Printf(\u0026#34;%d-------------\u0026gt;%s\\n\u0026#34;, key, value) } // 如何判断一个key值是否存在 // 第一个返回值为key所对应的value 第二个返回值为key是否存在的条件 存在ok为true value, ok := m[1] if ok == true { fmt.Println(\u0026#34;m[1]= \u0026#34;, value) } else { fmt.Println(\u0026#34;key不存在\u0026#34;) } //删除map元素 fmt.Println(\u0026#34;now:m = \u0026#34;, m) delete(m, 1) //删除key=1 fmt.Println(\u0026#34;delete:m = \u0026#34;, m) } 结构体普通变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var s1 Student = Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //指定成员初始化 没有初始化的成员 自动赋值为0 s2 := Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } s1 = {1 mike 109 18 bj}\ns2 = {0 mike 0 0 bj}\n结构体指针变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var p1 *Student = \u0026amp;Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;p1 = \u0026#34;, *p1) //指定成员初始化 没有初始化的成员 自动赋值为0 p2 := \u0026amp;Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Printf(\u0026#34;p2 type is %T\u0026#34;, p2) fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } [Running] go run \u0026ldquo;d:\\go\\workspace\\demo\\bibao.go\u0026rdquo;\np1 = {1 mike 109 18 bj}\np2 type is *main.Studentp2 = \u0026amp;{0 mike 0 0 bj}\n结构体成员使用：普通变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { var s Student //操作成员 需要使用.运算符 s.id = 1 s.name = \u0026#34;mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;s = \u0026#34;, s) } s = {1 mike 109 18 bj}\n结构体成员使用：指针变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 1.指针有合法指向后 才操作成员 // 2.先定义一个普通结构体变量 var s Student //再定义一个指针变量 保存s的地址 var p1 *Student p1 = \u0026amp;s // 通过指针操作成员 p1.id和（*p).id完全等价 只能使用.运算符 p1.age = 1 (*p1).name = \u0026#34;mike\u0026#34; p1.sex = \u0026#39;m\u0026#39; p1.age = 18 p1.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p1 = \u0026#34;, p1) // 2.通过New申请一个结构体 p2 := new(Student) p2.id = 1 p2.name = \u0026#34;mike\u0026#34; p2.age = 18 p2.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } p1 = \u0026amp;{0 mike 109 18 bj}\np2 = \u0026amp;{1 mike 0 18 bj}\n结构体比较和赋值 只能用!= ==和切片类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { s1 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s2 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s3 := Student{2, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 == s2\u0026#34;, s1 == s2) fmt.Println(\u0026#34;s1 == s3\u0026#34;, s1 == s3) //同类型的两个结构体可以互相赋值 var tmp Student tmp = s3 fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } s1 == s2 true\ns1 == s3 false\ntmp = {2 mike 109 18 bj}\n结构体做函数参数：值传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: {666 mike 109 18 bj}\nmain: {1 mike 109 18 bj}\n结构体做函数参数：地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s *Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(\u0026amp;s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: \u0026amp;{666 mike 109 18 bj}\nmain: {666 mike 109 18 bj}\ngo语言可见性规则验证 面向对象编程 l 封装：通过方法实现\nl 继承：通过匿名字段实现\nl 多态：通过接口实现\n匿名字段作用（继承） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { var s1 Student = Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //自动推导类型 s2 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) //%+v 显示更详细 fmt.Printf(\u0026#34;s2 = %+v\\n\u0026#34;, s2) } s1 = {{mike 109 18} 1 bj}\ns2 = {{mike 109 18} 1 bj}\ns2 = {Person:{name:mike sex:109 age:18} id:1 addr:bj}\n匿名字段初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { //顺序初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;sz\u0026#34;} //s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz} fmt.Printf(\u0026#34;s1 = %+v\\n\u0026#34;, s1) //s2 := Student{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, 1, \u0026#34;sz\u0026#34;} //err //部分成员初始化1 s3 := Student{Person: Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19}, id: 2} //s3 = {Person:{name:lily sex:102 age:19} id:2 addr:} fmt.Printf(\u0026#34;s3 = %+v\\n\u0026#34;, s3) //部分成员初始化2 s4 := Student{Person: Person{name: \u0026#34;tom\u0026#34;}, id: 3} //s4 = {Person:{name:tom sex:0 age:0} id:3 addr:} fmt.Printf(\u0026#34;s4 = %+v\\n\u0026#34;, s4) } s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz}\ns3 = {Person:{name:lily sex:102 age:19} id:2 addr:}\ns4 = {Person:{name:tom sex:0 age:0} id:3 addr:}\n成员操作 与结构体一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var s1 Student //变量声明 //给成员赋值 s1.name = \u0026#34;mike\u0026#34; //等价于 s1.Person.name = \u0026#34;mike\u0026#34; s1.sex = \u0026#39;m\u0026#39; s1.age = 18 s1.id = 1 s1.addr = \u0026#34;sz\u0026#34; fmt.Println(s1) //{{mike 109 18} 1 sz} var s2 Student //变量声明 s2.Person = Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19} s2.id = 2 s2.addr = \u0026#34;bj\u0026#34; fmt.Println(s2) //{{lily 102 19} 2 bj} 同名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string name string //和Person同名了 } func main() { var s Student //就近原则 如果能在本作用域找到此成员 就操作此成员 // 如果没有找到 找到继承字段 s.name = \u0026#34;Mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) // 显示调用 s.Person.name = \u0026#34;yoyo\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) } s = {Person:{name: sex:109 age:18} addr:bj name:Mike}s = {Person:{name:yoyo sex:109 age:18} addr:bj name:Mike}\n非结构体匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type mystr string //自定义类型 type Person struct { name string sex byte age int } type Student struct { Person // 匿名字段，结构体类型 int // 匿名字段，内置类型 mystr // 匿名字段，自定义类型 } func main() { //初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:{name:mike sex:109 age:18} int:1 mystr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //成员的操作，打印结果：mike, m, 18, 1, bj fmt.Printf(\u0026#34;%s, %c, %d, %d, %s\\n\u0026#34;, s1.name, s1.sex, s1.age, s1.int, s1.mystr) } 结构体指针类型匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Person struct { //人 name string sex byte age int } type Student struct { //学生 *Person // 匿名字段，结构体指针类型 id int addr string } func main() { //初始化 s1 := Student{\u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:0xc0420023e0 id:1 addr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //mike, m, 18 fmt.Printf(\u0026#34;%s, %c, %d\\n\u0026#34;, s1.name, s1.sex, s1.age) //声明变量 var s2 Student s2.Person = new(Person) //分配空间 s2.name = \u0026#34;yoyo\u0026#34; s2.sex = \u0026#39;f\u0026#39; s2.age = 20 s2.id = 2 s2.addr = \u0026#34;sz\u0026#34; //yoyo 102 20 2 20 fmt.Println(s2.name, s2.sex, s2.age, s2.id, s2.age) } 方法（封装） func(xxx Type){}绑定某种类型\n面向过程和面向对象函数区别 类似于this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; //实现两个数字相加 func Add01(a, b int) int { return a + b } // 方法：给某个类型绑定一个函数 type long int //tmp叫接受者 接受者就是传递一个参数 func (tmp long) Add02(other long) long { return tmp + other } func main() { var result int result = Add01(1, 1) fmt.Println(\u0026#34;result = \u0026#34;, result) //定义一个变量 var a long = 2 // 调用格式：变量名.函数（所需参数） r := a.Add02(3) fmt.Println(\u0026#34;r = \u0026#34;, r) //面向对象只是换了一种表现形式 } 结构体类型添加方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (tmp Person) PrintInfo() { fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } //通过一个函数 给成员赋值 func (p *Person) SetInfo(n string, s byte, a int) { p.name = n p.sex = s p.age = a } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() var p2 Person (\u0026amp;p2).SetInfo(\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 22) p2.PrintInfo() } tmp = {mike 109 18}\ntmp = {yoyo 102 22}\n方法使用总结 原来这个接受类型不能是指针\n只要接受类型不一样 这个方法就算同名 也是不同的方法 不会出现重复定义的函数\n值语义和引用语义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Person struct { name string sex byte age int } //指针作为接收者，引用语义 引用传递 func (p *Person) SetInfoPointer() { //给成员赋值 (*p).name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } //值作为接收者，值语义 一份拷贝 func (p Person) SetInfoValue() { //给成员赋值 p.name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } func main() { //指针作为接收者，引用语义 p1 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p1) //函数调用前 = {mike 109 18} (\u0026amp;p1).SetInfoPointer() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p1) //函数调用后 = {yoyo 102 22} fmt.Println(\u0026#34;==========================\u0026#34;) p2 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 //值作为接收者，值语义 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p2) //函数调用前 = {mike 109 18} p2.SetInfoValue() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p2) //函数调用后 = {mike 109 18} } %p打印地址\n指针类型和普通类型方法集 类型的方法集是指可以被该类型的值调用的所有方法的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //指针作为接收者，引用语义 func (p *Person) SetInfoPointer() { fmt.Println(\u0026#34;SetInfoPointer\u0026#34;) } //值作为接收者，值语义 func (p Person) SetInfoValue() { fmt.Println(\u0026#34;SetInfoValue\u0026#34;) } func main() { //结构体变量是一个指针变量 它能够调用哪些方法 这些方法就是一个集合 方法集 //p 为指针类型 p := \u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.SetInfoPointer() //func (p) SetInfoPointer() //内部做的转换 会先把指针p转成*p后再调用 // (*p).SetInfoValue() p.SetInfoValue() } 方法的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() } mike,m,18\nyoyo,f,20\n方法的重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func (tmp *Student) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d,%d,%s\\n\u0026#34;, tmp.name, tmp.sex, tmp.age, tmp.id, tmp.addr) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() //就近原则 先找本作用域的方法 找不到再用继承的方法 s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() s.Person.PrintInfo() } mike,m,18\nyoyo,f,20,2,sz\nyoyo,f,20\n方法值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfoPointer() //0xc0420023e0, \u0026amp;{mike 109 18} // 保存方式入口地址 pFunc1 := p.PrintInfoPointer //方法值，隐式传递 receiver 调用函数时 无需再传递接收者 pFunc1() //0xc0420023e0, \u0026amp;{mike 109 18} p.PrintInfoPointer pFunc2 := p.PrintInfoValue pFunc2() //0xc042048420, {mike 109 18} } 方法表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} fmt.Printf(\u0026#34;main:%p,%v\u0026#34;, \u0026amp;p, p) // 方法值隐藏了接受者 // 方法表达式 必须显示把接受者传递过去 f := (*Person).PrintInfoPointer f(\u0026amp;p) f2 := (Person).PrintInfoValue f2(p) } 接口 关于接口函数 在 Go 语言中，接口（interface）是一种非常重要的机制，它允许你定义一组方法，而不关心具体的实现类型。通过接口，我们可以编写更加灵活和通用的代码。\nGetter 接口是一个我们自定义的接口，用于获取某些数据。它要求实现它的类型必须提供一个 Get 方法，方法的签名如下：\n1 2 3 4 5 go 复制 Get(key string) ([]byte, error) 这个方法接受一个 key 字符串作为输入，返回一个 []byte（字节切片）和一个 error（可能的错误）。\n更详细的解释 我们先从一个更简单的场景开始：假设我们需要从不同的地方获取数据，比如从内存缓存或者从文件中读取。为了实现这些操作，我们定义了一个 Getter 接口，要求每个数据获取方式都要实现 Get 方法。\n1. 定义接口 1 2 3 go复制type Getter interface { Get(key string) ([]byte, error) } 这段代码定义了一个 Getter 接口，接口中有一个 Get 方法，要求实现这个接口的类型必须有 Get 方法，返回 []byte 和 error。\n2. 实现 Getter 接口的类型 接下来，我们可以定义一个或多个类型来实现这个 Getter 接口。举个例子：\n2.1 从内存缓存中获取数据\n我们可以创建一个 MemoryCache 类型来模拟内存缓存，并实现 Getter 接口。\n1 2 3 4 5 6 7 8 9 10 go复制type MemoryCache struct { data map[string][]byte } func (m *MemoryCache) Get(key string) ([]byte, error) { if value, exists := m.data[key]; exists { return value, nil } return nil, fmt.Errorf(\u0026#34;key not found: %s\u0026#34;, key) } MemoryCache 类型包含一个 data 字段，它是一个简单的 map，存储了缓存的 key 和 value。Get 方法尝试从这个 map 中查找指定的 key，如果找到了，就返回对应的 value；如果没有找到，就返回一个错误。\n2.2 从文件中获取数据\n我们还可以创建另一个 FileCache 类型来模拟从文件中读取数据：\n1 2 3 4 5 6 7 8 9 10 11 go复制type FileCache struct { filePath string } func (f *FileCache) Get(key string) ([]byte, error) { // 假设从文件读取逻辑，这里简化处理 if key == \u0026#34;fileKey\u0026#34; { return []byte(\u0026#34;file data for key: \u0026#34; + key), nil } return nil, fmt.Errorf(\u0026#34;file not found for key: %s\u0026#34;, key) } FileCache 类型模拟从文件读取数据，Get 方法根据传入的 key 返回相应的数据。如果没有找到对应的文件数据，就返回错误。\n3. 使用接口 现在我们有了两个不同的类型：MemoryCache 和 FileCache，它们都实现了 Getter 接口。我们可以通过 Getter 接口来统一处理这两种获取数据的方式，而不需要关心具体的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go复制func main() { // 创建内存缓存和文件缓存 memoryCache := \u0026amp;MemoryCache{data: map[string][]byte{\u0026#34;name\u0026#34;: []byte(\u0026#34;Alice\u0026#34;)}} fileCache := \u0026amp;FileCache{filePath: \u0026#34;/path/to/file\u0026#34;} // 定义一个 Getter 类型的变量 var getter Getter // 使用内存缓存获取数据 getter = memoryCache data, err := getter.Get(\u0026#34;name\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;MemoryCache data:\u0026#34;, string(data)) } // 使用文件缓存获取数据 getter = fileCache data, err = getter.Get(\u0026#34;fileKey\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;FileCache data:\u0026#34;, string(data)) } } 解释 MemoryCache 和 FileCache 实现了 Getter 接口： MemoryCache 实现了 Get 方法，负责从内存缓存中查找数据。 FileCache 实现了 Get 方法，负责从文件中读取数据。 统一使用接口类型 Getter： 在 main 函数中，我们声明了一个 getter 变量，它的类型是 Getter（接口类型）。然后我们把它分别指向了 MemoryCache 和 FileCache 类型的实例。 这样，无论是从内存缓存还是从文件缓存获取数据，我们都通过统一的 Get 方法来操作，而不需要关心具体的数据来源。 接口让代码更具通用性和灵活性： 我们可以很容易地扩展代码，添加更多实现了 Getter 接口的类型，比如从数据库获取数据。 通过接口，我们可以在不修改其他代码的情况下，灵活地切换数据来源。 总结 接口定义了一组方法，表示某种行为或操作。在这个例子中，Getter 接口定义了 Get 方法，表示“获取数据”。 任何类型只要实现了接口要求的所有方法，就可以被认为是实现了这个接口。 接口的好处是我们可以通过接口类型来处理不同的类型（如 MemoryCache 和 FileCache），从而使代码更具扩展性和通用性。 接口类型不能将其实例化。\n不关心对象是什么类型，到底是不是鸭子，只关心行为\n1 2 3 type Humaner interface { SayHi() } 接口定义和实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } func main() { // 定义接口类型的变量 var i Humaner // 只要实现了此接口方法的类型 那么这个类型的变量（接收者）就可以给i赋值 s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} i = s i.sayhi() t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} i = t i.sayhi() var str MyStr = \u0026#34;hello str\u0026#34; i = \u0026amp;str i.sayhi() } 多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } // 定义一个普通函数 函数参数为接口类型 func WhoSayHi(i Humaner) { i.sayhi() } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} var str MyStr = \u0026#34;hello str\u0026#34; // 调用同一函数 不同表现 多态 WhoSayHi(s) WhoSayHi(t) WhoSayHi(\u0026amp;str) } 接口继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type Humaner interface { SayHi() } type Personer interface { Humaner //这里想写了SayHi()一样 匿名字段 继承了sayhi() Sing(lyrics string) } type Student struct { //学生 name string id int } //Student实现SayHi()方法 func (tmp *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, tmp.name, tmp.score) } //Student实现Sing()方法 func (tmp *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //定义一个接口类型 var i2 Personer i2 = s i2.SayHi() //Student[mike, 88.880000] say hi!! i2.Sing(\u0026#34;学生哥\u0026#34;) //Student sing[学生哥]!! } 接口转换 //爸爸可以变成儿子 儿子不能变成爸爸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type Humaner interface { SayHi() } type Personer interface { Humaner //这里像写了SayHi()一样 Sing(lyrics string) } type Student struct { //学生 name string score float64 } //Student实现SayHi()方法 func (s *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, s.name, s.score) } //Student实现Sing()方法 func (s *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { //var i1 Humaner = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //var i2 Personer = i1 //err //Personer为超集，Humaner为子集 var i1 Personer = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} var i2 Humaner = i1 i2.SayHi() //Student[mike, 88.880000] say hi!! } 空接口 void *\n1 2 3 4 5 var v1 interface{} = 1 // 将int类型赋值给interface{} var v2 interface{} = \u0026#34;abc\u0026#34; // 将string类型赋值给interface{} var v3 interface{} = \u0026amp;v2 // 将*interface{}类型赋值给interface{} var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026amp;struct{ X int }{1} 当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：\n1 2 func Printf(fmt string, args ...interface{}) func Println(args ...interface{}) 通过if实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 // an int list[1] = \u0026#34;Hello\u0026#34; // a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} //类型查询 类型断言 //第一个返回下标 第二个返回下标对应的值 element 分别是i[0] i[1] i[2] for index, element := range list { //第一个返回的值 第二个返回判断结果的真假 if value, ok := element.(int); ok == true { fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) } else if value, ok := element.(string); ok { fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) } else if value, ok := element.(Person); ok { fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) } else { fmt.Printf(\u0026#34;list[%d] is of a different type\\n\u0026#34;, index) } } /* 打印结果： list[0] is an int and its value is 1 list[1] is a string and its value is Hello list[2] is a Person and its value is [mike, 18] */ } 通过switch实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 //an int list[1] = \u0026#34;Hello\u0026#34; //a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} for index, element := range list { switch value := element.(type) { case int: fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) case string: fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) case Person: fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) default: fmt.Println(\u0026#34;list[%d] is of a different type\u0026#34;, index) } } } error接口使用（普通错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { err1 := fmt.Errorf(\u0026#34;%s\u0026#34;, \u0026#34;this is normal error\u0026#34;) fmt.Println(\u0026#34;err1 = \u0026#34;, err1) err2 := errors.New(\u0026#34;this is error2\u0026#34;) fmt.Println(\u0026#34;err2 = \u0026#34;, err2) } err1 = this is normal error\nerr2 = this is error2\nerror接口应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func MyDiv(a, b int) (result int, err error) { err = nil if b == 0 { err = errors.New(\u0026#34;分母不能为0\u0026#34;) } else { result = a / b } return } func main() { result, err := MyDiv(10, 0) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } else { fmt.Println(\u0026#34;result = \u0026#34;, result) } } 显示调用panic函数（严重错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { // fmt.Println(\u0026#34;bbbbbbbb\u0026#34;) // 显示调用 panic 导致程序中断 panic(\u0026#34;this is a panic test\u0026#34;) } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } aaaaaaaa\npanic: this is a panic test\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:12\nmain.main()\nd:/go/workspace/demo/huidiao.go:20 +0x65\nexit status 2\n数组越界导致panic 一般不会是自己调用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\npanic: runtime error: index out of range [20] with length 10\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:11\nmain.main()\nd:/go/workspace/demo/huidiao.go:19 +0x5d\nexit status 2\nrecover的使用 必须放在defer调用的函数中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { // recover defer func() { //recover()//可以打印错误信息 // fmt.Println(recover()) if err := recover(); err != nil { //产生panic fmt.Println(err) } }() //调用此匿名函数 var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\nruntime error: index out of range [20] with length 10\ncccccccc\n字符串操作常用函数介绍 字符串操作代码验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // Contains :hellogo 中是否包含hello 包含返回true 不包含返回false fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;abc\u0026#34;)) // Joins 组合 s := []string{\u0026#34;abc\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;mike\u0026#34;, \u0026#34;go\u0026#34;} buf := strings.Join(s, \u0026#34;$\u0026#34;) fmt.Println(\u0026#34;buf = \u0026#34;, buf) // index 查找子串的位置 不存在返回-1 fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;go\u0026#34;)) //repeat 重复多少次 buf = strings.Repeat(\u0026#34;go\u0026#34;, 3) fmt.Println(\u0026#34;buf = \u0026#34;, buf) //split 以指定的分隔符拆分 buf = \u0026#34;hello@abc@go@mike\u0026#34; tmp := strings.Split(buf, \u0026#34;@\u0026#34;) fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) // Trim去掉两头的字符 buf = strings.Trim(\u0026#34; are u ok? \u0026#34;, \u0026#34; \u0026#34;) //去掉两头的空格 fmt.Printf(\u0026#34;buf = #%s#\\n\u0026#34;, buf) // Field 去掉空格 把元素放入切片中 s3 := strings.Fields(\u0026#34; are u ok? \u0026#34;) //fmt.Println(\u0026#34;s3= \u0026#34;, s3) for i, data := range s3 { fmt.Println(i, \u0026#34;,\u0026#34;, data) } } true\nfalse\nbuf = abc$hello$mike$go\n4\n-1\nbuf = gogogo\ntmp = [hello abc go mike]\nbuf = #are u ok?#\n0 , are\n1 , u\n2 , ok?\n字符串转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 转换为字符串后追加到字节数组 slice := make([]byte, 0, 1024) slice = strconv.AppendBool(slice, true) //第二个数字是要追加的数字 第三个为指定十进制方式追加 slice = strconv.AppendInt(slice, 1234, 10) slice = strconv.AppendQuote(slice, \u0026#34;abcgohello\u0026#34;) fmt.Println(\u0026#34;slice = \u0026#34;, string(slice)) //转换string再打印 // 其他类型转换为字符串 var str string str = strconv.FormatBool(false) //\u0026#39;f\u0026#39;指打印格式 以小数方式 -1指小数点后位数 （紧缩模式） 64以float64 str = strconv.FormatFloat(3.14, \u0026#39;f\u0026#39;, -1, 64) fmt.Println(\u0026#34;str = \u0026#34;, str) // 整型转字符串 str = strconv.Itoa(6666) fmt.Println(\u0026#34;str = \u0026#34;, str) // 字符串转其他类型 flag, err := strconv.ParseBool(\u0026#34;true\u0026#34;) if err == nil { fmt.Println(\u0026#34;flag = \u0026#34;, flag) } else { fmt.Println(\u0026#34;err = \u0026#34;, err) } // 字符串转换为整型 a, _ := strconv.Atoi(\u0026#34;5678\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) } slice = true1234\u0026quot;abcgohello\u0026quot;\nstr = 3.14\nstr = 6666\nflag = true\na = 5678\n正则表达式 模式匹配 关键字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { buf := \u0026#34;abc azc a7c aac 888 a9c tac\u0026#34; // 1）解释规则，它会解析正则表达式 如果成功返回*regexp 解释器 失败返回errors a开头中间任意字符 结尾c reg1 := regexp.MustCompile(`a[0-9]c`) if reg1 == nil { //解析失败 fmt.Println(\u0026#34;regexp error\u0026#34;) return } // 2）根据规则提取关键信息 -1匹配所有 1只有一个 result1 := reg1.FindAllStringSubmatch(buf, -1) fmt.Println(\u0026#34;result1 = \u0026#34;, result1) } result1 = [[a7c] [a9c]]\nJSON介绍 通过结构体生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 type IT struct { Company string Subjects []string IsOk bool Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 buf, err := json.Marshal(s) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\u0026ldquo;Company\u0026rdquo;:\u0026ldquo;itcast\u0026rdquo;,\u0026ldquo;Subjects\u0026rdquo;:[\u0026ldquo;Go\u0026rdquo;,\u0026ldquo;C++\u0026rdquo;,\u0026ldquo;Python\u0026rdquo;,\u0026ldquo;Test\u0026rdquo;],\u0026ldquo;IsOk\u0026rdquo;:true,\u0026ldquo;Price\u0026rdquo;:888.888}\n格式化编码：\nbuf, err := json.MarshalIndent(s, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) //格式化编码\n输出：\nbuf = {\n\u0026ldquo;Company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;Subjects\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: true,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\nstruct_tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 // type IT struct { // Company string // Subjects []string // IsOk bool // Price float64 // } type IT struct { Company string `json:\u0026#34;company\u0026#34;` // 此字段不会输出到屏幕 Subjects []string `json:\u0026#34;subject\u0026#34;` // 二次编码 IsOk bool `json:\u0026#34;,string\u0026#34;` // bool转换成string Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 // buf, err := json.Marshal(s) buf, err := json.MarshalIndent(s, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) //格式化编码 if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\n\u0026ldquo;company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;subject\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: \u0026ldquo;true\u0026rdquo;,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\n通过map生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //创建一个map m := make(map[string]interface{}, 4) m[\u0026#34;company\u0026#34;] = \u0026#34;itcast\u0026#34; m[\u0026#34;subject\u0026#34;] = []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;} m[\u0026#34;isok\u0026#34;] = true m[\u0026#34;price\u0026#34;] = 666.666 //编码成JSON result, err := json.Marshal(m) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } fmt.Println(\u0026#34;result = \u0026#34;, string(result)) } json解析到结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type IT struct { Company string `json:\u0026#34;company\u0026#34;` Subjects []string `json:\u0026#34;subjects\u0026#34;` IsOk bool `json:\u0026#34;isok\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t IT //定义一个结构体变量 err := json.Unmarshal([]byte(jsonBuf), \u0026amp;t) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //运行结果：{itcast [Go C++ Python Test] true 666.666} //只想要Subjects字段 type IT2 struct { Subjects []string `json:\u0026#34;subjects\u0026#34;` } var t2 IT2 err = json.Unmarshal(jsonBuf, \u0026amp;t2) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t2) //运行结果：{[Go C++ Python Test]} } json解析到map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) //创建一个map m := make(map[string]interface{}) err := json.Unmarshal([]byte(jsonBuf), \u0026amp;m) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Printf(\u0026#34;m = %+v\\n\u0026#34;, m) // var str string // str = string(m[\u0026#34;company\u0026#34;])//err 无法转换 //fmt.Println(\u0026#34;str = \u0026#34;,str) //这是错误的 //类型断言 for key, value := range m { fmt.Printf(\u0026#34;%v ---------------\u0026gt; %v\\n\u0026#34;, key, value) if key == \u0026#34;company\u0026#34; { str := value fmt.Println(\u0026#34;str = \u0026#34;, str) } } } func main() { b := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t interface{} err := json.Unmarshal(b, \u0026amp;t) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //使用断言判断类型 m := t.(map[string]interface{}) for k, v := range m { switch vv := v.(type) { case string: fmt.Println(k, \u0026#34;is string\u0026#34;, vv) case int: fmt.Println(k, \u0026#34;is int\u0026#34;, vv) case float64: fmt.Println(k, \u0026#34;is float64\u0026#34;, vv) case bool: fmt.Println(k, \u0026#34;is bool\u0026#34;, vv) case []interface{}: fmt.Println(k, \u0026#34;is an array:\u0026#34;) for i, u := range vv { fmt.Println(i, u) } default: fmt.Println(k, \u0026#34;is of a type I don\u0026#39;t know how to handle\u0026#34;) } } } 文件分类和为什么需要文件 设备文件：屏幕（标准输出设备）\n​\tfmt.println() 往标准输出设备写内容\n键盘（标准输入设备）\n​\tfmt.Scanf()往标准输入设备读取内容\n磁盘文件：放在存储设备上的文件\n​\t文本文件 二进制文件\n文件常用操作接口介绍 标准设备文件的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } WriteString 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } Read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { fin, err := os.Open(\u0026#34;./xxx.txt\u0026#34;) //打开文件 if err != nil { fmt.Println(err) } defer fin.Close() buf := make([]byte, 1024) //开辟1024个字节的slice作为缓冲 for { n, _ := fin.Read(buf) //读文件 if n == 0 { //0表示已经到文件结束 break } fmt.Println(string(buf)) //输出读取的内容 } } 借助bufo实现按行读取 拷贝文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args //获取用户输入的所有参数 //如果用户没有输入,或参数个数不够,则调用该函数提示用户 if args == nil || len(args) != 3 { fmt.Println(\u0026#34;useage : xxx srcFile dstFile\u0026#34;) return } srcPath := args[1] //获取输入的第一个参数 dstPath := args[2] //获取输入的第二个参数 fmt.Printf(\u0026#34;srcPath = %s, dstPath = %s\\n\u0026#34;, srcPath, dstPath) if srcPath == dstPath { fmt.Println(\u0026#34;源文件和目的文件名字不能相同\u0026#34;) return } srcFile, err1 := os.Open(srcPath) //打开源文件 if err1 != nil { fmt.Println(err1) return } dstFile, err2 := os.Create(dstPath) //创建目的文件 if err2 != nil { fmt.Println(err2) return } buf := make([]byte, 1024) //切片缓冲区 for { //从源文件读取内容，n为读取文件内容的长度 n, err := srcFile.Read(buf) if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(err) break } if n == 0 { fmt.Println(\u0026#34;文件处理完毕\u0026#34;) break } //切片截取 tmp := buf[:n] //把读取的内容写入到目的文件 dstFile.Write(tmp) } //关闭文件 srcFile.Close() dstFile.Close() } 并发和并行的区别 并行是两个队列同时使用两台咖啡机\n并发就是两个队列交替使用一台咖啡机\n创建goroutine goroutine是GO的协程\n协程 比线程更小\n内部实现内存共享\n主函数就是主goroutine\n后面就是子协程 这是并发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 for { fmt.Println(\u0026#34;this is a main goroutine\u0026#34;) time.Sleep(time.Second) } } 程序起点就是主函数\n只要看到go 就开了一个新的协程\n两个任务同时操作（时间片轮转）\n在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建\n主协程先退出 主goroutine退出后，其它的工作goroutine也会自动退出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 fmt.Println(\u0026#34;main goroutine exit\u0026#34;) } 主协程先退出导致子协程来不及调用 runtime：Gosched的使用 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。\n这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { go func() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;go\u0026#34;) } }() for i := 0; i \u0026lt; 2; i++ { // 让出时间片 先让别的协议执行 它执行完 再回来执行此协程 runtime.Gosched() fmt.Println(\u0026#34;hello\u0026#34;) } } go\ngo\ngo\ngo\ngo\nhello\nhello\nruntime：Goexit的使用 调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\nddddddddddddddddd\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) return //终止此函数 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) runtime.Goexit() //终止所在协程 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\ngo func()和test()在同一个协程\nruntime：GoMAXPROCS的使用 调用 runtime.GOMAXPROCS() 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。\n1 2 3 4 5 6 7 8 9 10 func main() { //n := runtime.GOMAXPROCS(1) //打印结果：111111111111111111110000000000000000000011111... n := runtime.GOMAXPROCS(2) //打印结果：010101010101010101011001100101011010010100110... fmt.Printf(\u0026#34;n = %d\\n\u0026#34;, n) for { go fmt.Print(0) fmt.Print(1) } } 在第一次执行(runtime.GOMAXPROCS(1))时，最多同时只能有一个goroutine被执行。所以\n会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。\n在第二次执行(runtime.GOMAXPROCS(2))时，我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。\n多任务资源竞争问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } func Person1() { Printer(\u0026#34;hello\u0026#34;) } func Person2() { Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } //打印结果乱码：hwoerllldo 最终要实现同步：我打印完你才能打印 于是引出了channel\nchannel介绍 goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。\n引⽤类型 channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。\n相当于一个水管 一边放东西 一边取东西 没东西就阻塞\n可以通过make 来创建 引用类型\n1 2 make(chan Type) //等价于make(chan Type, 0) make(chan Type, capacity) 当 capacity= 0 时，channel 是无缓冲阻塞读写的，当capacity\u0026gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。\nchannel通过操作符\u0026lt;-来接收和发送数据，发送和接收数据语法：\n1 2 3 4 channel \u0026lt;- value //发送value到channel \u0026lt;-channel //接收并将其丢弃 x := \u0026lt;-channel //从channel中接收数据，并赋值给x x, ok := \u0026lt;-channel //功能同上，同时检查通道是否已关闭或者是否为空 通过channel实现同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan int) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } //person1执行完才能到person2 func Person1() { Printer(\u0026#34;hello\u0026#34;) ch \u0026lt;- 666 //给管道写数据 } func Person2() { \u0026lt;-ch //从管道取数据 接收 如果通道没有数据 就会阻塞 Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } hello\nworld\n通过channel实现同步和数据交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan string) func main() { go func() { defer fmt.Println(\u0026#34;子协程调用完毕\u0026#34;) for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;子协程 i = \u0026#34;, i) time.Sleep(time.Second) } ch \u0026lt;- \u0026#34;我是子协程 工作完毕\u0026#34; }() // 不让主协程结束 死循环 str := \u0026lt;-ch //没有数据一直阻塞 fmt.Println(\u0026#34;str = \u0026#34;, str) } 子协程 i = 0\n子协程 i = 1\n子协程调用完毕\nstr = 我是子协程 工作完毕\n无缓冲channel 无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。\n这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。\n这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。\n下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值：\n不能存储 等于没有存储箱 一旦上交数据必须接受 交换完成才会解锁goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) //无缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=0\n子协程： i = 0,\nnum = 0\n子协程正在运行[0]: len(c)=0, cap(c)=0\n子协程： i = 1,\n子协程正在运行[1]: len(c)=0, cap(c)=0\n子协程： i = 2,\nnum = 1\nnum = 2\nmain协程结束\n有缓冲channel 这个可以缓存 指定容量就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程： i = 0,\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程： i = 1,\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程： i = 2,\n子协程正在运行[2]: len(c)=3, cap(c)=3\n子协程结束\nnum = 0\nnum = 1\nnum = 2\nmain协程结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 10; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 10; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程正在运行[2]: len(c)=3, cap(c)=3\nnum = 0\nnum = 1\nnum = 2\nnum = 3\n子协程正在运行[3]: len(c)=2, cap(c)=3\n子协程正在运行[4]: len(c)=0, cap(c)=3\n子协程正在运行[5]: len(c)=1, cap(c)=3\n子协程正在运行[6]: len(c)=2, cap(c)=3\n子协程正在运行[7]: len(c)=3, cap(c)=3\nnum = 4\nnum = 5\nnum = 6\nnum = 7\nnum = 8\n子协程正在运行[8]: len(c)=0, cap(c)=3\n子协程正在运行[9]: len(c)=0, cap(c)=3\n子协程结束\nnum = 9\nmain协程结束\n关闭channel 如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 if data, ok := \u0026lt;-c; ok 那一行 close(ch) }() for { //ok为true说明channel没有关闭，为false说明管道已经关闭 if data, ok := \u0026lt;-ch; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Finished\u0026#34;) 0\n1\n2\n3\n4\nFinished\n通过range遍历channel内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 for data := range c 那一行 close(c) }() for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Finished\u0026#34;) } 单向channel 默认情况下，通道是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。\n但是，我们经常见一个通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。\n1 2 3 var ch1 chan int // ch1是一个正常的channel，不是单向的 var ch2 chan\u0026lt;- float64 // ch2是单向channel，只用于写float64数据 var ch3 \u0026lt;-chan int // ch3是单向channel，只用于读取int数据 双向channel可以隐式转换成单向的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; // only write func producer(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { out \u0026lt;- i * i } close(out) } //only read func consumer(in \u0026lt;-chan int) { for num := range in { fmt.Println(\u0026#34;num = \u0026#34;, num) } } func main() { // 创建一个双向通道 ch := make(chan int) // 生产者，生产数字 写入channel // 新开一个协程 go producer(ch) //channel传参 引用传递 // 消费者，从channel读取内容 consumer(ch) } num = 0\nnum = 1\nnum = 4\nnum = 9\nnum = 16\nnum = 25\nnum = 36\nnum = 49\nnum = 64\nnum = 81\nTimer的使用 Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) //验证time.newTimer()时间到了是否只会相应一次 func main() { timer := time.NewTimer(1 * time.Second) for { \u0026lt;-timer.C fmt.Println(\u0026#34;时间到\u0026#34;) } } func main01() { // 创建一个定时器 设置时间为2s 2s后往通道写内容 当前时间 timer := time.NewTimer(2 * time.Second) fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) //2s后会往timer.C写数据 有数据后就可以读取 t := \u0026lt;-timer.C //channel没有数据前后阻塞 fmt.Println(\u0026#34;t = \u0026#34;, t) } 时间到\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\nmain.main()\nd:/go/workspace/demo/bibao.go:14 +0x2a\nexit status 2\nTimer实现延时功能 1 2 3 4 func main(){ \u0026lt;-time.After(2*time.Second) fmt.Println(\u0026#34;时间到\u0026#34;) } 定时器停止 timer.Stop()\n定时器重置 timer.Reset(time.Second)\nTicker的使用 Ticker是一个定时触发的计时器，它会以一个间隔(interval)往channel发送一个事件(当前时间)，而channel的接收者可以以固定的时间间隔从channel中读取事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间) ticker := time.NewTicker(time.Second * 1) i := 0 go func() { for { //循环 \u0026lt;-ticker.C i++ fmt.Println(\u0026#34;i = \u0026#34;, i) if i == 5 { ticker.Stop() //停止定时器 } } }() //别忘了() //死循环，特地不让main goroutine结束 for { } } select的作用 监听channel上的数据流动方向\nselect的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。\n与switch语句可以选择任何可使用相等比较的条件相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：\n1 2 3 4 5 6 7 8 select { case \u0026lt;-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u0026lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } 在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。\n如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。\n如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：\nl 如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。\nl 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。\n通过select实现斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; // ch只写 quit只读 func fibonacci(ch chan\u0026lt;- int, quit \u0026lt;-chan bool) { x, y := 1, 1 for { // 监听channel数据流动 select { case ch \u0026lt;- x: x, y = y, x+y case flag := \u0026lt;-quit: fmt.Println(\u0026#34;flag = \u0026#34;, flag) return } } } func main() { ch := make(chan int) // 数字通信 quit := make(chan bool) //程序是否结束 // 消费者 从channel读取内容 //新建协程 go func() { for i := 0; i \u0026lt; 8; i++ { num := \u0026lt;-ch fmt.Println(\u0026#34;num = \u0026#34;, num) } //可以停止 quit \u0026lt;- true }() // 生产者 产生数字 写入channel fibonacci(ch, quit) } num = 1\nnum = 1\nnum = 2\nnum = 3\nnum = 5\nnum = 8\nnum = 13\nnum = 21\nflag = true\nselect实现的超时机制 有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { c := make(chan int) o := make(chan bool) go func() { for { select { case v := \u0026lt;-c: fmt.Println(v) case \u0026lt;-time.After(5 * time.Second): fmt.Println(\u0026#34;timeout\u0026#34;) o \u0026lt;- true break } } }() //c \u0026lt;- 666 // 注释掉，引发 timeout \u0026lt;-o } 简易TCP服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { // 监听 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } defer listener.Close() // 阻塞等待用户请求 conn, err := listener.Accept() if err != nil { fmt.Printf(\u0026#34;err = \u0026#34;, err) return } // 接收用户请求 buf := make([]byte, 1024) n, err1 := conn.Read(buf) if err1 != nil { fmt.Println(\u0026#34;err1 = \u0026#34;, err1) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf[:n])) defer conn.Close() // 关闭当前用户连接 } 简易TCP客户端 传输文件功能 发送方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) // 发送文件内容 func SendFile(path string, conn net.Conn) { //以只读方式打开文件 f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;os.Open err = \u0026#34;, err) return } defer f.Close() buf := make([]byte, 4096) // 读文件内容 读多少发多少 一点不差 for { n, err := f.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件发送完毕\u0026#34;) } else { fmt.Println(\u0026#34;f.read err = \u0026#34;, err) } return } // 发送内容 conn.Write(buf[:n]) } } func main() { // 提示输入文件 fmt.Println(\u0026#34;请输入需要传输的文件：\u0026#34;) var path string fmt.Scan(\u0026amp;path) // 获取文件名info.Name() info, err := os.Stat(path) if err != nil { fmt.Println(\u0026#34;os.Stat err = \u0026#34;, err) return } // 主动连接服务器 conn, err1 := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err1 != nil { fmt.Println(\u0026#34;net.Dial err1 = \u0026#34;, err1) return } defer conn.Close() var n int // 给接收方先发送文件名 _, err = conn.Write([]byte(info.Name())) if err != nil { fmt.Println(\u0026#34;conn.Write err = \u0026#34;, err) return } // 接收对方的回复 如果回复\u0026#34;ok\u0026#34;说明对方准备好 可以发送文件 buf := make([]byte, 1024) n, err2 := conn.Read(buf) if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } if n \u0026gt; 0 \u0026amp;\u0026amp; string(buf[:n]) == \u0026#34;ok\u0026#34; { // 发送文件内容 SendFile(path, conn) } } 接收方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func RecvFile(fileName string, conn net.Conn) { //新建文件 f, err := os.Create(fileName) if err != nil { fmt.Println(\u0026#34;os.Create err = \u0026#34;, err) return } buf := make([]byte, 1024) // 接收多少就写多少 for { n, err := conn.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) } else { fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) } return } if n == 0 { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) break } f.Write(buf[:n]) } } func main() { //监听 listennner, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listennner.Close() // 阻塞等待用户连接 conn, err1 := listennner.Accept() if err1 != nil { fmt.Println(\u0026#34;listenner accept err = \u0026#34;, err1) return } defer conn.Close() buf := make([]byte, 1024) var n int n, err2 := conn.Read(buf) //读取对方发送的文件名 if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } fileName := string(buf[:n]) // 回复\u0026#34;ok\u0026#34; conn.Write([]byte(\u0026#34;ok\u0026#34;)) // 接收文件内容 RecvFile(fileName, conn) } 并发聊天服务器 用户一上线就会给当前在线的客户端都会发送谁上线了这个信息\n原理分析：\n公共聊天室\n显示IP和说的话\n如何知道有多少个用户上线\nmap增加成员\n好处：假设有个人发送一个hello 这里有三个客户端都要发送这个hello 不管哪个人 我都遍历map 类似于广播\nmap保存这些在线用户 key-value\nkey值:ip+端口\nvalue:用户名+addr（key） + channel -\u0026gt; 结构体type Client struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Client struct { C chan string Name string Addr string // 和KEY一样 } var onlineMap map[string]Client //主要协程 处理用户连接 ：将用户加入map 2)告诉所有在线用户 谁上线了 message\u0026lt;- 有人上线了 //新开一个协程 定义一个管道 这个协程死循环 //go协程 把用户发过来的数据转发 用户发过来的数据是buf message\u0026lt;-buf //下线从map移除 var message = make(chan string) //管道用来传输信息 发送信息 传递参数cli go func(){ for{ msg := \u0026lt;-message //如果有内容 //遍历map 看有多少个成员 for _,cli:=range(onlineMap){ } } }() 广播上线 广播消息 查询在线用户 修改用户名 用户主动退出 超时处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type Client struct { C chan string //用户发送数据的管道 Name string //用户名 Addr string //网络地址 } // 保存在线用户 cliAdd ======\u0026gt;Client var Online map[string]Client var message = make(chan string) // 新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 func Manager() { //给map分配空间 Online = make(map[string]Client) for { msg := \u0026lt;-message //没有消息前阻塞 //遍历map 给每个map成员发送消息 for _, cli := range Online { cli.C \u0026lt;- msg } } } func WriteMsgToClient(cli Client, conn net.Conn) { for msg := range cli.C { conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) } } func MakeMsg(cli Client, msg string) (buf string) { buf = \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;: \u0026#34; + msg return } func HandleConn(conn net.Conn) { //处理用户连接 defer conn.Close() // 获取客户端的网络地址 cliAddr := conn.RemoteAddr().String() // 创建一个结构体 cli := Client{make(chan string), cliAddr, cliAddr} //把结构体添加到map Online[cliAddr] = cli //新开一个协程 专门给当前的客户端发送信息 go WriteMsgToClient(cli, conn) //广播某个在线 //message \u0026lt;- \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;:login\u0026#34; message \u0026lt;- MakeMsg(cli, \u0026#34;login\u0026#34;) //提示我是谁 cli.C \u0026lt;- MakeMsg(cli, \u0026#34;I am here!\u0026#34;) isQuit := make(chan bool) //对方是否主动退出 hasData := make(chan bool) //对方是否有数据发送 //新开一个协程 接收用户发送过来的数据 go func() { buf := make([]byte, 2048) for { n, err := conn.Read(buf) if n == 0 { //对方断开或者出问题 isQuit \u0026lt;- true fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) return } msg := string(buf[:n-1]) //Windows nc测试 多一个换行符 写n-1 if len(msg) == 3 \u0026amp;\u0026amp; msg == \u0026#34;who\u0026#34; { //遍历map 给当前用户发送所有成员 conn.Write([]byte(\u0026#34;user list : \\n\u0026#34;)) for _, tmp := range Online { msg = tmp.Addr + \u0026#34;:\u0026#34; + tmp.Name + \u0026#34;\\n\u0026#34; conn.Write([]byte(msg)) } } else if len(msg) \u0026gt;= 8 \u0026amp;\u0026amp; msg[:6] == \u0026#34;rename\u0026#34; { //rename|mike name := strings.Split(msg, \u0026#34;|\u0026#34;)[1] cli.Name = name Online[cliAddr] = cli conn.Write([]byte(\u0026#34;rename ok\\n\u0026#34;)) } else { //转发此内容 message \u0026lt;- MakeMsg(cli, string(msg)) } hasData \u0026lt;- true //代表 有数据 } }() for { //通过select来检测channel的流动 select { case \u0026lt;-isQuit: delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;login out\\n\u0026#34;) //广播谁下线了 return case \u0026lt;-hasData: case \u0026lt;-time.After(60 * time.Second): //60s超时 delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;time out leave out\\n\u0026#34;) //广播谁下线了 return } } } func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listener.Close() //新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 go Manager() //主协程 循环阻塞等待用户连接 for { conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;Listener.accept err = \u0026#34;, err) continue } go HandleConn(conn) //处理用户连接 } } HTTP编程 ","date":"2025-02-15T23:20:17+08:00","permalink":"https://paipai2001.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/","title":"Go语言学习"},{"content":"GO语言学习 day01:基础类型\nday02:函数工程管理\nday03:复合类型\nday04:oop\nday05:异常文本文件处理\nday06:并发编程\nday07:网络概述\nday08:http编程\n回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; type FuncType func(int, int) int func Add(a, b int) int { return a + b } //回调函数 函数有一个参数是函数类型 这个函数就是回调函数 //计算器 可以进行四则运算 //多态，多种形态，调用同一个接口，不同的表现，从一个接口可以实现不同表现 加减乘除 // 先有想法 后面再实现功能 //可扩展性 func Calc(a, b int, fTest FuncType) (result int) { fmt.Println(\u0026#34;Calc\u0026#34;) result = fTest(a, b) //这个函数还没有实现 //result = Add(a,b)//必须先定义才能使用 return } func main() { a := Calc(1, 1, Add) fmt.Println(\u0026#34;a = \u0026#34;, a) } 匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; //匿名函数 没有函数名字 f1 := func() { //:=自动推导类型 fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;str = \u0026#34;, str) } f1() //给一个函数类型起别名 type FuncType func() // 函数没有参数 没有返回值 var f2 FuncType f2 = f1 f2() //定义匿名函数 同时调用 func() { fmt.Println(\u0026#34;a = %d str = %s\u0026#34;, a, str) }() //后面的()代表调用这个匿名函数 // 带参数的匿名函数 f3 := func(i, j int) { fmt.Printf(\u0026#34;i = %d,j = %d\u0026#34;, i, j) } f3(10, 20) //匿名函数 有参有返回值 x, y := func(i, j int) (max, min int) { if i \u0026gt; j { max = i min = j } else { max = j min = i } return }(10, 20) fmt.Printf(\u0026#34;x = %d y = %d\\n\u0026#34;, x, y) } 闭包 不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; func() { //闭包以引用方式捕获外部变量 a = 666 str = \u0026#34;go\u0026#34; fmt.Printf(\u0026#34;a = %d, str = %s\\n\u0026#34;, a, str) }() //()代表直接调用 fmt.Printf(\u0026#34;outside:a = %d, str = %s\\n\u0026#34;, a, str) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func test01() int { var x int //没有初始化 值为0 x++ return x * x } func main() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } 1 2 3 4 5 PS D:\\go\\workspace\\demo\u0026gt; go run bibao.go 1 1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; //函数返回值是一个匿名函数 返回一个函数类型 func test02() func() int { var x int return func() int { x++ return x * x } } func main() { //返回值为一个匿名函数 所以返回一个函数类型 通过f 调用返回的匿名函数 //它不关心这些捕获了的变量和常量是否已经超出了作用域 // 所以只要闭包还在使用它 这些变量就还会存在 f := test02() fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) } func test01() int { //函数被调用时，x才分配空间，才初始化为0 var x int //没有初始化 值为0 x++ return x * x //函数调用完毕，x自动释放 } func main01() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } defer延迟调用 1 2 3 package main import \u0026#34;fmt\u0026#34; 获取命令行参数 1 2 3 4 package main import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; 工程管理 同一个目录下：\n分文件编程 必须放在src目录\n设置gopath环境变量\n同一个目录 包名必须一样\ngo env 查看go相关环境路径\n同一个目录 调用别的文件函数 直接调用即可 无需包名引用\n不同目录下：\nsrc:main.go\nsrc/calc:calc.go\n不同目录 包名不一样\n调用不同包里面的函数 格式：包名.函数名（)\n也要import “calc”\n调用别的包函数 如果函数名字开头小写 无法调用\n必须首字母大写\n变量内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int = 10 fmt.Printf(\u0026#34;a = %d\\n\u0026#34;, a) fmt.Printf(\u0026#34;\u0026amp;a = %v\\n\u0026#34;, \u0026amp;a) //保存某个变量地址 需要指针类型 *int 保存int的地址 ** int 保存 *int地址 var p *int p = \u0026amp;a //指针变量指向谁 就把谁的地址赋值给指针变量 // fmt.Printf(\u0026#34;*p = %v, a= %v\u0026#34;, *p, a) } 不要操作没有合法指向内存 值传递和地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { *a, *b = *b, *a fmt.Printf(\u0026#34;swap:a = %d,b = %d\\n\u0026#34;, *a, *b) } func main() { a, b := 10, 20 swap(\u0026amp;a, \u0026amp;b) //变量本身传递 值传递 fmt.Printf(\u0026#34;main:a = %d,b = %d\\n\u0026#34;, a, b) } 数组array 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { // 数组同一个类型的集合 var id [50]int for i := 0; i \u0026lt; len(id); i++ { id[i] = i + 1 fmt.Printf(\u0026#34;%d\\n\u0026#34;, id[i]) } } 数组基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { var a [10]int var b [5]int fmt.Printf(\u0026#34;len(a) = %d len(b) = %d\\n\u0026#34;, len(a), len(b)) // 注意数组元素个数必须是常量 // n:= 10 // var c [n]int error non-constant array boud n // 下标可以是变量或者常量 a[0] = 1 i := 1 a[i] = 2 for i := 0; i \u0026lt; len(a); i++ { a[i] = i + 1 fmt.Printf(\u0026#34;%d\u0026#34;, a[i]) } for i, data := range a { fmt.Printf(\u0026#34;a[%d] = %d\\n\u0026#34;, i, data) } } 数组初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { //声明定义同时赋值 叫初始化 // 全部初始化 var a [5]int = [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;a = \u0026#34;, a) // b := [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;b = \u0026#34;, b) // 部分初始化 没有初始化的元素 自动赋值为0 c := [5]int{1, 2, 3} fmt.Println(\u0026#34;c = \u0026#34;, c) // 指定某个元素初始化 d := [5]int{2: 10, 4: 20} fmt.Println(\u0026#34;d = \u0026#34;, d) } 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func main() { var a [3][4]int k := 0 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 4; j++ { k++ a[i][j] = k fmt.Printf(\u0026#34;a[%d][%d] = %d \u0026#34;, i, j, a[i][j]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}} fmt.Println(\u0026#34;b= \u0026#34;, b) // 部分初始化 其他值为0 c := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}, {9, 10}} fmt.Println(\u0026#34;c= \u0026#34;, c) d := [3][4]int{1:{5, 6, 7, 8}} fmt.Println(\u0026#34;d= \u0026#34;, d) } 数组比较和赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { // 支持比较 只支持==或者!= 比较是不是每个元素都一样 两个数组比较 类型必须一致 a := [5]int{1, 2, 3, 4, 5} b := [5]int{1, 2, 3, 4, 5} c := [5]int{1, 2, 3} fmt.Println(\u0026#34; a == b \u0026#34;, a == b) fmt.Println(\u0026#34;a == c \u0026#34;, a == c) // 同类型的数组可以赋值 var d [5]int d = a fmt.Println(\u0026#34;d = \u0026#34;, d) } 随机数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;rand = \u0026#34;, rand.Intn(100)) //限制在100以内 } } 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 var a [10]int n := len(a) for i := 0; i \u0026lt; n; i++ { a[i] = rand.Intn(100) fmt.Printf(\u0026#34;%d \u0026#34;, a[i]) //限制在100以内 } fmt.Printf(\u0026#34;\\n\u0026#34;) for i := 0; i \u0026lt; n-1; i++ { for j := 0; j \u0026lt; n-i-1; j++ { if a[j] \u0026gt; a[j+1] { a[j], a[j+1] = a[j+1], a[j] } } } fmt.Printf(\u0026#34;\\n排序后:\\n\u0026#34;) for i := 0; i \u0026lt; n; i++ { fmt.Printf(\u0026#34;%v \u0026#34;, a[i]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } 数组做函数参数是值拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; // 数组做函数参数 值传递 // 实参数组的每个元素给形参拷贝一份 //形参数组是实参数组的复制品 func modify(a [5]int) { a[0] = 666 fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(a) fmt.Println(\u0026#34;a = \u0026#34;, a) } 数组指针做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; //p指向实参数组a 数组指针 // *p代表指针指向内存 也就是实参a func modify(p *[5]int) { (*p)[0] = 666 fmt.Println(\u0026#34;p = \u0026#34;, *p) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(\u0026amp;a) //地址传递 fmt.Println(\u0026#34;a = \u0026#34;, a) } 切片 实现变长数组方案:需要用一个数组保存学生成绩 但是学生个数不确定\n不是真正意义的动态数组 只是一个引用类型 总是指向一个底层array\narray := [\u0026hellip;]int{10,20,30,9,0}\nslice:=array[0:3:5]\n[low:high:max]\nlow:下标起点\nhigh:下标终点\nmax:容量\n左闭右开 不包括high下标\nlen = high-low\ncap = max-low\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { a := []int{1, 2, 3, 0, 0} s := a[0:3:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) s = a[1:4:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) } 数组和切片区别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import \u0026#34;fmt\u0026#34; func main() { //自动推导类型 s1 := []int{1, 2, 3, 4} fmt.Println(\u0026#34;s1= \u0026#34;, s1) //make 格式：make(切片类型,len,cap) s2 := make([]int, 5, 10) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s2), cap(s2)) // 没有指定容量 容量和长度一样 s3 := make([]int, 5) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s3), cap(s3)) } func main01() { //切片和数组的区别 //数组[]里面的长度是一个固定的常量 数组不能修改长度 len和cap永远都是5 a := [5]int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(a), cap(a)) // 切片 []里面为空 或者为... // 切片的长度或者容量可以不固定 s := []int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) s = append(s, 11) //给切片末尾追加一个成员 fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) } 切片截取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { array := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := array[:] //[0:len(array):len(array)]不指定容量和长度一样 fmt.Println(\u0026#34;s1 = \u0026#34;, s1) fmt.Printf(\u0026#34;len(s1) = %d,cap(s1) = %d\\n\u0026#34;, len(s1), cap(s1)) //操作某个元素 和数组操作方式一样 data := array[0] fmt.Printf(\u0026#34;data=%v\\n\u0026#34;, data) s2 := array[3:6:7] //a[3] a[4] a[5] len = 6-3=3 cap = 7-3 = 4 fmt.Printf(\u0026#34;len(s2) = %d,cap(s2) = %d\\n\u0026#34;, len(s2), cap(s2)) s3 := array[:6] //从0开始 去6个元素 容量也是6 fmt.Println(\u0026#34;s3 = \u0026#34;, s3) fmt.Printf(\u0026#34;len(s3) = %d,cap(s3) = %d\\n\u0026#34;, len(s3), cap(s3)) s4 := array[3:] //从下标为3开始 到结尾 fmt.Println(\u0026#34;s4 = \u0026#34;, s4) fmt.Printf(\u0026#34;len(s4) = %d,cap(s4) = %d\\n\u0026#34;, len(s4), cap(s4)) } append函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { s1 := []int{} fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //在原切片末尾添加元素 s1 = append(s1, 1) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s1 = append(s1, 2, 3) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s2 := []int{1, 2, 3} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) s2 = append(s2, 3, 4, 5) fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } 扩容特点：\n如果超过原来的容量 通常以两倍容量扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { s := make([]int, 0, 1) oldCap := cap(s) for i := 0; i \u0026lt; 8; i++ { s = append(s, i) if newCap := cap(s); oldCap \u0026lt; newCap { fmt.Printf(\u0026#34;cap:%d=====\u0026gt;%d\\n\u0026#34;, oldCap, newCap) oldCap = newCap } } } copy使用 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { srcSlice := []int{1, 2} dstSlice := []int{6, 6, 6, 6, 6} copy(dstSlice, srcSlice) fmt.Println(\u0026#34;dst = \u0026#34;, dstSlice) } dst = [1 2 6 6 6]\n切片做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func test(s []int) { //切片做函数参数 s[0] = -1 fmt.Println(\u0026#34;test : \u0026#34;) for i, v := range s { fmt.Printf(\u0026#34;s[%d]=%d, \u0026#34;, i, v) //s[0]=-1, s[1]=1, s[2]=2, s[3]=3, s[4]=4, s[5]=5, s[6]=6, s[7]=7, s[8]=8, s[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} test(slice) fmt.Println(\u0026#34;main : \u0026#34;) for i, v := range slice { fmt.Printf(\u0026#34;slice[%d]=%d, \u0026#34;, i, v) //slice[0]=-1, slice[1]=1, slice[2]=2, slice[3]=3, slice[4]=4, slice[5]=5, slice[6]=6, slice[7]=7, slice[8]=8, slice[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } 猜数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func CreatNum(p *int) { rand.Seed(time.Now().UnixNano()) num := rand.Intn(9000) + 1000 *p = num } func GetNum(s []int, num int) { s[0] = num / 1000 s[1] = num % 1000 / 100 s[2] = num % 100 / 10 s[3] = num % 10 } func OnGame(randNum []int) { var num int for { for { fmt.Printf(\u0026#34;请输入一个四位数：\u0026#34;) fmt.Scan(\u0026amp;num) if num \u0026gt; 999 \u0026amp;\u0026amp; num \u0026lt; 10000 { break } fmt.Printf(\u0026#34;输入数字不是四位数 请重新输入：\u0026#34;) } fmt.Println(\u0026#34;num = \u0026#34;, num) keySlice := make([]int, 4) GetNum(keySlice, num) fmt.Println(\u0026#34;keyslice = \u0026#34;, keySlice) n := 0 for i := 0; i \u0026lt; 4; i++ { if randNum[i] \u0026lt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 大了一点\\n\u0026#34;, i+1) } else if randNum[i] \u0026gt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 小了一点\\n\u0026#34;, i+1) } else { fmt.Printf(\u0026#34;第%d位 猜对了 要再接再厉\\n\u0026#34;, i+1) n++ } } if n == 4 { fmt.Println(\u0026#34;全部猜对啦！\u0026#34;) break } } } func main() { var randNum int //产生一个4位的随机数 CreatNum(\u0026amp;randNum) fmt.Println(\u0026#34;randNum: \u0026#34;, randNum) randSlice := make([]int, 4) GetNum(randSlice, randNum) fmt.Println(\u0026#34;randSlice = \u0026#34;, randSlice) OnGame(randSlice) //游戏 } map 键值对 字典\nmap[int]string{\n110:\u0026ldquo;string\u0026rdquo;\n111:\u0026ldquo;void\u0026rdquo;\n}\n注意是无序的 返回顺序不一定\n键值唯一 切片不能做键值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string var m1 map[int]string fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //对于map只有len,没有cap fmt.Println(\u0026#34;len = \u0026#34;, len(m1)) //可以通过make创建 可以指定长度 m2 := make(map[int]string) fmt.Println(\u0026#34;m2 = \u0026#34;, m2) fmt.Println(\u0026#34;len = \u0026#34;, len(m2)) //这个指定的长度其实是容量 m3 := make(map[int]string, 10) m3[1] = \u0026#34;mike\u0026#34; m3[2] = \u0026#34;go\u0026#34; m3[3] = \u0026#34;c++\u0026#34; fmt.Println(\u0026#34;m3 = \u0026#34;, m3) fmt.Println(\u0026#34;len = \u0026#34;, len(m3)) //初始化 键值必须是唯一的 m4 := map[int]string{1: \u0026#34;mike\u0026#34;} fmt.Println(\u0026#34;m4 = \u0026#34;, m4) fmt.Println(\u0026#34;len = \u0026#34;, len(m4)) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string m1 := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;} fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //不存在直接加上 m1[3] = \u0026#34;c++\u0026#34; //存在就修改 m1[1] = \u0026#34;go\u0026#34; fmt.Println(\u0026#34;now:m1 = \u0026#34;, m1) m := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;, 3: \u0026#34;go\u0026#34;} // 第一个返回值是key 第二个返回值是value 遍历结果是无序的 for key, value := range m { fmt.Printf(\u0026#34;%d-------------\u0026gt;%s\\n\u0026#34;, key, value) } // 如何判断一个key值是否存在 // 第一个返回值为key所对应的value 第二个返回值为key是否存在的条件 存在ok为true value, ok := m[1] if ok == true { fmt.Println(\u0026#34;m[1]= \u0026#34;, value) } else { fmt.Println(\u0026#34;key不存在\u0026#34;) } //删除map元素 fmt.Println(\u0026#34;now:m = \u0026#34;, m) delete(m, 1) //删除key=1 fmt.Println(\u0026#34;delete:m = \u0026#34;, m) } 结构体普通变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var s1 Student = Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //指定成员初始化 没有初始化的成员 自动赋值为0 s2 := Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } s1 = {1 mike 109 18 bj}\ns2 = {0 mike 0 0 bj}\n结构体指针变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var p1 *Student = \u0026amp;Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;p1 = \u0026#34;, *p1) //指定成员初始化 没有初始化的成员 自动赋值为0 p2 := \u0026amp;Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Printf(\u0026#34;p2 type is %T\u0026#34;, p2) fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } [Running] go run \u0026ldquo;d:\\go\\workspace\\demo\\bibao.go\u0026rdquo;\np1 = {1 mike 109 18 bj}\np2 type is *main.Studentp2 = \u0026amp;{0 mike 0 0 bj}\n结构体成员使用：普通变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { var s Student //操作成员 需要使用.运算符 s.id = 1 s.name = \u0026#34;mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;s = \u0026#34;, s) } s = {1 mike 109 18 bj}\n结构体成员使用：指针变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 1.指针有合法指向后 才操作成员 // 2.先定义一个普通结构体变量 var s Student //再定义一个指针变量 保存s的地址 var p1 *Student p1 = \u0026amp;s // 通过指针操作成员 p1.id和（*p).id完全等价 只能使用.运算符 p1.age = 1 (*p1).name = \u0026#34;mike\u0026#34; p1.sex = \u0026#39;m\u0026#39; p1.age = 18 p1.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p1 = \u0026#34;, p1) // 2.通过New申请一个结构体 p2 := new(Student) p2.id = 1 p2.name = \u0026#34;mike\u0026#34; p2.age = 18 p2.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } p1 = \u0026amp;{0 mike 109 18 bj}\np2 = \u0026amp;{1 mike 0 18 bj}\n结构体比较和赋值 只能用!= ==和切片类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { s1 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s2 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s3 := Student{2, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 == s2\u0026#34;, s1 == s2) fmt.Println(\u0026#34;s1 == s3\u0026#34;, s1 == s3) //同类型的两个结构体可以互相赋值 var tmp Student tmp = s3 fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } s1 == s2 true\ns1 == s3 false\ntmp = {2 mike 109 18 bj}\n结构体做函数参数：值传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: {666 mike 109 18 bj}\nmain: {1 mike 109 18 bj}\n结构体做函数参数：地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s *Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(\u0026amp;s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: \u0026amp;{666 mike 109 18 bj}\nmain: {666 mike 109 18 bj}\ngo语言可见性规则验证 面向对象编程 l 封装：通过方法实现\nl 继承：通过匿名字段实现\nl 多态：通过接口实现\n匿名字段作用（继承） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { var s1 Student = Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //自动推导类型 s2 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) //%+v 显示更详细 fmt.Printf(\u0026#34;s2 = %+v\\n\u0026#34;, s2) } s1 = {{mike 109 18} 1 bj}\ns2 = {{mike 109 18} 1 bj}\ns2 = {Person:{name:mike sex:109 age:18} id:1 addr:bj}\n匿名字段初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { //顺序初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;sz\u0026#34;} //s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz} fmt.Printf(\u0026#34;s1 = %+v\\n\u0026#34;, s1) //s2 := Student{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, 1, \u0026#34;sz\u0026#34;} //err //部分成员初始化1 s3 := Student{Person: Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19}, id: 2} //s3 = {Person:{name:lily sex:102 age:19} id:2 addr:} fmt.Printf(\u0026#34;s3 = %+v\\n\u0026#34;, s3) //部分成员初始化2 s4 := Student{Person: Person{name: \u0026#34;tom\u0026#34;}, id: 3} //s4 = {Person:{name:tom sex:0 age:0} id:3 addr:} fmt.Printf(\u0026#34;s4 = %+v\\n\u0026#34;, s4) } s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz}\ns3 = {Person:{name:lily sex:102 age:19} id:2 addr:}\ns4 = {Person:{name:tom sex:0 age:0} id:3 addr:}\n成员操作 与结构体一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var s1 Student //变量声明 //给成员赋值 s1.name = \u0026#34;mike\u0026#34; //等价于 s1.Person.name = \u0026#34;mike\u0026#34; s1.sex = \u0026#39;m\u0026#39; s1.age = 18 s1.id = 1 s1.addr = \u0026#34;sz\u0026#34; fmt.Println(s1) //{{mike 109 18} 1 sz} var s2 Student //变量声明 s2.Person = Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19} s2.id = 2 s2.addr = \u0026#34;bj\u0026#34; fmt.Println(s2) //{{lily 102 19} 2 bj} 同名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string name string //和Person同名了 } func main() { var s Student //就近原则 如果能在本作用域找到此成员 就操作此成员 // 如果没有找到 找到继承字段 s.name = \u0026#34;Mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) // 显示调用 s.Person.name = \u0026#34;yoyo\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) } s = {Person:{name: sex:109 age:18} addr:bj name:Mike}s = {Person:{name:yoyo sex:109 age:18} addr:bj name:Mike}\n非结构体匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type mystr string //自定义类型 type Person struct { name string sex byte age int } type Student struct { Person // 匿名字段，结构体类型 int // 匿名字段，内置类型 mystr // 匿名字段，自定义类型 } func main() { //初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:{name:mike sex:109 age:18} int:1 mystr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //成员的操作，打印结果：mike, m, 18, 1, bj fmt.Printf(\u0026#34;%s, %c, %d, %d, %s\\n\u0026#34;, s1.name, s1.sex, s1.age, s1.int, s1.mystr) } 结构体指针类型匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Person struct { //人 name string sex byte age int } type Student struct { //学生 *Person // 匿名字段，结构体指针类型 id int addr string } func main() { //初始化 s1 := Student{\u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:0xc0420023e0 id:1 addr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //mike, m, 18 fmt.Printf(\u0026#34;%s, %c, %d\\n\u0026#34;, s1.name, s1.sex, s1.age) //声明变量 var s2 Student s2.Person = new(Person) //分配空间 s2.name = \u0026#34;yoyo\u0026#34; s2.sex = \u0026#39;f\u0026#39; s2.age = 20 s2.id = 2 s2.addr = \u0026#34;sz\u0026#34; //yoyo 102 20 2 20 fmt.Println(s2.name, s2.sex, s2.age, s2.id, s2.age) } 方法（封装） func(xxx Type){}绑定某种类型\n面向过程和面向对象函数区别 类似于this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; //实现两个数字相加 func Add01(a, b int) int { return a + b } // 方法：给某个类型绑定一个函数 type long int //tmp叫接受者 接受者就是传递一个参数 func (tmp long) Add02(other long) long { return tmp + other } func main() { var result int result = Add01(1, 1) fmt.Println(\u0026#34;result = \u0026#34;, result) //定义一个变量 var a long = 2 // 调用格式：变量名.函数（所需参数） r := a.Add02(3) fmt.Println(\u0026#34;r = \u0026#34;, r) //面向对象只是换了一种表现形式 } 结构体类型添加方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (tmp Person) PrintInfo() { fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } //通过一个函数 给成员赋值 func (p *Person) SetInfo(n string, s byte, a int) { p.name = n p.sex = s p.age = a } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() var p2 Person (\u0026amp;p2).SetInfo(\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 22) p2.PrintInfo() } tmp = {mike 109 18}\ntmp = {yoyo 102 22}\n方法使用总结 原来这个接受类型不能是指针\n只要接受类型不一样 这个方法就算同名 也是不同的方法 不会出现重复定义的函数\n值语义和引用语义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Person struct { name string sex byte age int } //指针作为接收者，引用语义 引用传递 func (p *Person) SetInfoPointer() { //给成员赋值 (*p).name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } //值作为接收者，值语义 一份拷贝 func (p Person) SetInfoValue() { //给成员赋值 p.name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } func main() { //指针作为接收者，引用语义 p1 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p1) //函数调用前 = {mike 109 18} (\u0026amp;p1).SetInfoPointer() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p1) //函数调用后 = {yoyo 102 22} fmt.Println(\u0026#34;==========================\u0026#34;) p2 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 //值作为接收者，值语义 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p2) //函数调用前 = {mike 109 18} p2.SetInfoValue() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p2) //函数调用后 = {mike 109 18} } %p打印地址\n指针类型和普通类型方法集 类型的方法集是指可以被该类型的值调用的所有方法的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //指针作为接收者，引用语义 func (p *Person) SetInfoPointer() { fmt.Println(\u0026#34;SetInfoPointer\u0026#34;) } //值作为接收者，值语义 func (p Person) SetInfoValue() { fmt.Println(\u0026#34;SetInfoValue\u0026#34;) } func main() { //结构体变量是一个指针变量 它能够调用哪些方法 这些方法就是一个集合 方法集 //p 为指针类型 p := \u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.SetInfoPointer() //func (p) SetInfoPointer() //内部做的转换 会先把指针p转成*p后再调用 // (*p).SetInfoValue() p.SetInfoValue() } 方法的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() } mike,m,18\nyoyo,f,20\n方法的重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func (tmp *Student) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d,%d,%s\\n\u0026#34;, tmp.name, tmp.sex, tmp.age, tmp.id, tmp.addr) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() //就近原则 先找本作用域的方法 找不到再用继承的方法 s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() s.Person.PrintInfo() } mike,m,18\nyoyo,f,20,2,sz\nyoyo,f,20\n方法值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfoPointer() //0xc0420023e0, \u0026amp;{mike 109 18} // 保存方式入口地址 pFunc1 := p.PrintInfoPointer //方法值，隐式传递 receiver 调用函数时 无需再传递接收者 pFunc1() //0xc0420023e0, \u0026amp;{mike 109 18} p.PrintInfoPointer pFunc2 := p.PrintInfoValue pFunc2() //0xc042048420, {mike 109 18} } 方法表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} fmt.Printf(\u0026#34;main:%p,%v\u0026#34;, \u0026amp;p, p) // 方法值隐藏了接受者 // 方法表达式 必须显示把接受者传递过去 f := (*Person).PrintInfoPointer f(\u0026amp;p) f2 := (Person).PrintInfoValue f2(p) } 接口 关于接口函数 在 Go 语言中，接口（interface）是一种非常重要的机制，它允许你定义一组方法，而不关心具体的实现类型。通过接口，我们可以编写更加灵活和通用的代码。\nGetter 接口是一个我们自定义的接口，用于获取某些数据。它要求实现它的类型必须提供一个 Get 方法，方法的签名如下：\n1 2 3 4 5 go 复制 Get(key string) ([]byte, error) 这个方法接受一个 key 字符串作为输入，返回一个 []byte（字节切片）和一个 error（可能的错误）。\n更详细的解释 我们先从一个更简单的场景开始：假设我们需要从不同的地方获取数据，比如从内存缓存或者从文件中读取。为了实现这些操作，我们定义了一个 Getter 接口，要求每个数据获取方式都要实现 Get 方法。\n1. 定义接口 1 2 3 go复制type Getter interface { Get(key string) ([]byte, error) } 这段代码定义了一个 Getter 接口，接口中有一个 Get 方法，要求实现这个接口的类型必须有 Get 方法，返回 []byte 和 error。\n2. 实现 Getter 接口的类型 接下来，我们可以定义一个或多个类型来实现这个 Getter 接口。举个例子：\n2.1 从内存缓存中获取数据\n我们可以创建一个 MemoryCache 类型来模拟内存缓存，并实现 Getter 接口。\n1 2 3 4 5 6 7 8 9 10 go复制type MemoryCache struct { data map[string][]byte } func (m *MemoryCache) Get(key string) ([]byte, error) { if value, exists := m.data[key]; exists { return value, nil } return nil, fmt.Errorf(\u0026#34;key not found: %s\u0026#34;, key) } MemoryCache 类型包含一个 data 字段，它是一个简单的 map，存储了缓存的 key 和 value。Get 方法尝试从这个 map 中查找指定的 key，如果找到了，就返回对应的 value；如果没有找到，就返回一个错误。\n2.2 从文件中获取数据\n我们还可以创建另一个 FileCache 类型来模拟从文件中读取数据：\n1 2 3 4 5 6 7 8 9 10 11 go复制type FileCache struct { filePath string } func (f *FileCache) Get(key string) ([]byte, error) { // 假设从文件读取逻辑，这里简化处理 if key == \u0026#34;fileKey\u0026#34; { return []byte(\u0026#34;file data for key: \u0026#34; + key), nil } return nil, fmt.Errorf(\u0026#34;file not found for key: %s\u0026#34;, key) } FileCache 类型模拟从文件读取数据，Get 方法根据传入的 key 返回相应的数据。如果没有找到对应的文件数据，就返回错误。\n3. 使用接口 现在我们有了两个不同的类型：MemoryCache 和 FileCache，它们都实现了 Getter 接口。我们可以通过 Getter 接口来统一处理这两种获取数据的方式，而不需要关心具体的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go复制func main() { // 创建内存缓存和文件缓存 memoryCache := \u0026amp;MemoryCache{data: map[string][]byte{\u0026#34;name\u0026#34;: []byte(\u0026#34;Alice\u0026#34;)}} fileCache := \u0026amp;FileCache{filePath: \u0026#34;/path/to/file\u0026#34;} // 定义一个 Getter 类型的变量 var getter Getter // 使用内存缓存获取数据 getter = memoryCache data, err := getter.Get(\u0026#34;name\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;MemoryCache data:\u0026#34;, string(data)) } // 使用文件缓存获取数据 getter = fileCache data, err = getter.Get(\u0026#34;fileKey\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;FileCache data:\u0026#34;, string(data)) } } 解释 MemoryCache 和 FileCache 实现了 Getter 接口： MemoryCache 实现了 Get 方法，负责从内存缓存中查找数据。 FileCache 实现了 Get 方法，负责从文件中读取数据。 统一使用接口类型 Getter： 在 main 函数中，我们声明了一个 getter 变量，它的类型是 Getter（接口类型）。然后我们把它分别指向了 MemoryCache 和 FileCache 类型的实例。 这样，无论是从内存缓存还是从文件缓存获取数据，我们都通过统一的 Get 方法来操作，而不需要关心具体的数据来源。 接口让代码更具通用性和灵活性： 我们可以很容易地扩展代码，添加更多实现了 Getter 接口的类型，比如从数据库获取数据。 通过接口，我们可以在不修改其他代码的情况下，灵活地切换数据来源。 总结 接口定义了一组方法，表示某种行为或操作。在这个例子中，Getter 接口定义了 Get 方法，表示“获取数据”。 任何类型只要实现了接口要求的所有方法，就可以被认为是实现了这个接口。 接口的好处是我们可以通过接口类型来处理不同的类型（如 MemoryCache 和 FileCache），从而使代码更具扩展性和通用性。 接口类型不能将其实例化。\n不关心对象是什么类型，到底是不是鸭子，只关心行为\n1 2 3 type Humaner interface { SayHi() } 接口定义和实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } func main() { // 定义接口类型的变量 var i Humaner // 只要实现了此接口方法的类型 那么这个类型的变量（接收者）就可以给i赋值 s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} i = s i.sayhi() t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} i = t i.sayhi() var str MyStr = \u0026#34;hello str\u0026#34; i = \u0026amp;str i.sayhi() } 多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } // 定义一个普通函数 函数参数为接口类型 func WhoSayHi(i Humaner) { i.sayhi() } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} var str MyStr = \u0026#34;hello str\u0026#34; // 调用同一函数 不同表现 多态 WhoSayHi(s) WhoSayHi(t) WhoSayHi(\u0026amp;str) } 接口继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type Humaner interface { SayHi() } type Personer interface { Humaner //这里想写了SayHi()一样 匿名字段 继承了sayhi() Sing(lyrics string) } type Student struct { //学生 name string id int } //Student实现SayHi()方法 func (tmp *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, tmp.name, tmp.score) } //Student实现Sing()方法 func (tmp *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //定义一个接口类型 var i2 Personer i2 = s i2.SayHi() //Student[mike, 88.880000] say hi!! i2.Sing(\u0026#34;学生哥\u0026#34;) //Student sing[学生哥]!! } 接口转换 //爸爸可以变成儿子 儿子不能变成爸爸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type Humaner interface { SayHi() } type Personer interface { Humaner //这里像写了SayHi()一样 Sing(lyrics string) } type Student struct { //学生 name string score float64 } //Student实现SayHi()方法 func (s *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, s.name, s.score) } //Student实现Sing()方法 func (s *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { //var i1 Humaner = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //var i2 Personer = i1 //err //Personer为超集，Humaner为子集 var i1 Personer = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} var i2 Humaner = i1 i2.SayHi() //Student[mike, 88.880000] say hi!! } 空接口 void *\n1 2 3 4 5 var v1 interface{} = 1 // 将int类型赋值给interface{} var v2 interface{} = \u0026#34;abc\u0026#34; // 将string类型赋值给interface{} var v3 interface{} = \u0026amp;v2 // 将*interface{}类型赋值给interface{} var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026amp;struct{ X int }{1} 当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：\n1 2 func Printf(fmt string, args ...interface{}) func Println(args ...interface{}) 通过if实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 // an int list[1] = \u0026#34;Hello\u0026#34; // a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} //类型查询 类型断言 //第一个返回下标 第二个返回下标对应的值 element 分别是i[0] i[1] i[2] for index, element := range list { //第一个返回的值 第二个返回判断结果的真假 if value, ok := element.(int); ok == true { fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) } else if value, ok := element.(string); ok { fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) } else if value, ok := element.(Person); ok { fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) } else { fmt.Printf(\u0026#34;list[%d] is of a different type\\n\u0026#34;, index) } } /* 打印结果： list[0] is an int and its value is 1 list[1] is a string and its value is Hello list[2] is a Person and its value is [mike, 18] */ } 通过switch实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 //an int list[1] = \u0026#34;Hello\u0026#34; //a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} for index, element := range list { switch value := element.(type) { case int: fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) case string: fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) case Person: fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) default: fmt.Println(\u0026#34;list[%d] is of a different type\u0026#34;, index) } } } error接口使用（普通错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { err1 := fmt.Errorf(\u0026#34;%s\u0026#34;, \u0026#34;this is normal error\u0026#34;) fmt.Println(\u0026#34;err1 = \u0026#34;, err1) err2 := errors.New(\u0026#34;this is error2\u0026#34;) fmt.Println(\u0026#34;err2 = \u0026#34;, err2) } err1 = this is normal error\nerr2 = this is error2\nerror接口应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func MyDiv(a, b int) (result int, err error) { err = nil if b == 0 { err = errors.New(\u0026#34;分母不能为0\u0026#34;) } else { result = a / b } return } func main() { result, err := MyDiv(10, 0) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } else { fmt.Println(\u0026#34;result = \u0026#34;, result) } } 显示调用panic函数（严重错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { // fmt.Println(\u0026#34;bbbbbbbb\u0026#34;) // 显示调用 panic 导致程序中断 panic(\u0026#34;this is a panic test\u0026#34;) } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } aaaaaaaa\npanic: this is a panic test\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:12\nmain.main()\nd:/go/workspace/demo/huidiao.go:20 +0x65\nexit status 2\n数组越界导致panic 一般不会是自己调用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\npanic: runtime error: index out of range [20] with length 10\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:11\nmain.main()\nd:/go/workspace/demo/huidiao.go:19 +0x5d\nexit status 2\nrecover的使用 必须放在defer调用的函数中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { // recover defer func() { //recover()//可以打印错误信息 // fmt.Println(recover()) if err := recover(); err != nil { //产生panic fmt.Println(err) } }() //调用此匿名函数 var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\nruntime error: index out of range [20] with length 10\ncccccccc\n字符串操作常用函数介绍 字符串操作代码验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // Contains :hellogo 中是否包含hello 包含返回true 不包含返回false fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;abc\u0026#34;)) // Joins 组合 s := []string{\u0026#34;abc\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;mike\u0026#34;, \u0026#34;go\u0026#34;} buf := strings.Join(s, \u0026#34;$\u0026#34;) fmt.Println(\u0026#34;buf = \u0026#34;, buf) // index 查找子串的位置 不存在返回-1 fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;go\u0026#34;)) //repeat 重复多少次 buf = strings.Repeat(\u0026#34;go\u0026#34;, 3) fmt.Println(\u0026#34;buf = \u0026#34;, buf) //split 以指定的分隔符拆分 buf = \u0026#34;hello@abc@go@mike\u0026#34; tmp := strings.Split(buf, \u0026#34;@\u0026#34;) fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) // Trim去掉两头的字符 buf = strings.Trim(\u0026#34; are u ok? \u0026#34;, \u0026#34; \u0026#34;) //去掉两头的空格 fmt.Printf(\u0026#34;buf = #%s#\\n\u0026#34;, buf) // Field 去掉空格 把元素放入切片中 s3 := strings.Fields(\u0026#34; are u ok? \u0026#34;) //fmt.Println(\u0026#34;s3= \u0026#34;, s3) for i, data := range s3 { fmt.Println(i, \u0026#34;,\u0026#34;, data) } } true\nfalse\nbuf = abc$hello$mike$go\n4\n-1\nbuf = gogogo\ntmp = [hello abc go mike]\nbuf = #are u ok?#\n0 , are\n1 , u\n2 , ok?\n字符串转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 转换为字符串后追加到字节数组 slice := make([]byte, 0, 1024) slice = strconv.AppendBool(slice, true) //第二个数字是要追加的数字 第三个为指定十进制方式追加 slice = strconv.AppendInt(slice, 1234, 10) slice = strconv.AppendQuote(slice, \u0026#34;abcgohello\u0026#34;) fmt.Println(\u0026#34;slice = \u0026#34;, string(slice)) //转换string再打印 // 其他类型转换为字符串 var str string str = strconv.FormatBool(false) //\u0026#39;f\u0026#39;指打印格式 以小数方式 -1指小数点后位数 （紧缩模式） 64以float64 str = strconv.FormatFloat(3.14, \u0026#39;f\u0026#39;, -1, 64) fmt.Println(\u0026#34;str = \u0026#34;, str) // 整型转字符串 str = strconv.Itoa(6666) fmt.Println(\u0026#34;str = \u0026#34;, str) // 字符串转其他类型 flag, err := strconv.ParseBool(\u0026#34;true\u0026#34;) if err == nil { fmt.Println(\u0026#34;flag = \u0026#34;, flag) } else { fmt.Println(\u0026#34;err = \u0026#34;, err) } // 字符串转换为整型 a, _ := strconv.Atoi(\u0026#34;5678\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) } slice = true1234\u0026quot;abcgohello\u0026quot;\nstr = 3.14\nstr = 6666\nflag = true\na = 5678\n正则表达式 模式匹配 关键字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { buf := \u0026#34;abc azc a7c aac 888 a9c tac\u0026#34; // 1）解释规则，它会解析正则表达式 如果成功返回*regexp 解释器 失败返回errors a开头中间任意字符 结尾c reg1 := regexp.MustCompile(`a[0-9]c`) if reg1 == nil { //解析失败 fmt.Println(\u0026#34;regexp error\u0026#34;) return } // 2）根据规则提取关键信息 -1匹配所有 1只有一个 result1 := reg1.FindAllStringSubmatch(buf, -1) fmt.Println(\u0026#34;result1 = \u0026#34;, result1) } result1 = [[a7c] [a9c]]\nJSON介绍 通过结构体生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 type IT struct { Company string Subjects []string IsOk bool Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 buf, err := json.Marshal(s) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\u0026ldquo;Company\u0026rdquo;:\u0026ldquo;itcast\u0026rdquo;,\u0026ldquo;Subjects\u0026rdquo;:[\u0026ldquo;Go\u0026rdquo;,\u0026ldquo;C++\u0026rdquo;,\u0026ldquo;Python\u0026rdquo;,\u0026ldquo;Test\u0026rdquo;],\u0026ldquo;IsOk\u0026rdquo;:true,\u0026ldquo;Price\u0026rdquo;:888.888}\n格式化编码：\nbuf, err := json.MarshalIndent(s, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) //格式化编码\n输出：\nbuf = {\n\u0026ldquo;Company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;Subjects\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: true,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\nstruct_tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 // type IT struct { // Company string // Subjects []string // IsOk bool // Price float64 // } type IT struct { Company string `json:\u0026#34;company\u0026#34;` // 此字段不会输出到屏幕 Subjects []string `json:\u0026#34;subject\u0026#34;` // 二次编码 IsOk bool `json:\u0026#34;,string\u0026#34;` // bool转换成string Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 // buf, err := json.Marshal(s) buf, err := json.MarshalIndent(s, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) //格式化编码 if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\n\u0026ldquo;company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;subject\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: \u0026ldquo;true\u0026rdquo;,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\n通过map生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //创建一个map m := make(map[string]interface{}, 4) m[\u0026#34;company\u0026#34;] = \u0026#34;itcast\u0026#34; m[\u0026#34;subject\u0026#34;] = []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;} m[\u0026#34;isok\u0026#34;] = true m[\u0026#34;price\u0026#34;] = 666.666 //编码成JSON result, err := json.Marshal(m) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } fmt.Println(\u0026#34;result = \u0026#34;, string(result)) } json解析到结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type IT struct { Company string `json:\u0026#34;company\u0026#34;` Subjects []string `json:\u0026#34;subjects\u0026#34;` IsOk bool `json:\u0026#34;isok\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t IT //定义一个结构体变量 err := json.Unmarshal([]byte(jsonBuf), \u0026amp;t) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //运行结果：{itcast [Go C++ Python Test] true 666.666} //只想要Subjects字段 type IT2 struct { Subjects []string `json:\u0026#34;subjects\u0026#34;` } var t2 IT2 err = json.Unmarshal(jsonBuf, \u0026amp;t2) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t2) //运行结果：{[Go C++ Python Test]} } json解析到map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) //创建一个map m := make(map[string]interface{}) err := json.Unmarshal([]byte(jsonBuf), \u0026amp;m) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Printf(\u0026#34;m = %+v\\n\u0026#34;, m) // var str string // str = string(m[\u0026#34;company\u0026#34;])//err 无法转换 //fmt.Println(\u0026#34;str = \u0026#34;,str) //这是错误的 //类型断言 for key, value := range m { fmt.Printf(\u0026#34;%v ---------------\u0026gt; %v\\n\u0026#34;, key, value) if key == \u0026#34;company\u0026#34; { str := value fmt.Println(\u0026#34;str = \u0026#34;, str) } } } func main() { b := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t interface{} err := json.Unmarshal(b, \u0026amp;t) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //使用断言判断类型 m := t.(map[string]interface{}) for k, v := range m { switch vv := v.(type) { case string: fmt.Println(k, \u0026#34;is string\u0026#34;, vv) case int: fmt.Println(k, \u0026#34;is int\u0026#34;, vv) case float64: fmt.Println(k, \u0026#34;is float64\u0026#34;, vv) case bool: fmt.Println(k, \u0026#34;is bool\u0026#34;, vv) case []interface{}: fmt.Println(k, \u0026#34;is an array:\u0026#34;) for i, u := range vv { fmt.Println(i, u) } default: fmt.Println(k, \u0026#34;is of a type I don\u0026#39;t know how to handle\u0026#34;) } } } 文件分类和为什么需要文件 设备文件：屏幕（标准输出设备）\n​\tfmt.println() 往标准输出设备写内容\n键盘（标准输入设备）\n​\tfmt.Scanf()往标准输入设备读取内容\n磁盘文件：放在存储设备上的文件\n​\t文本文件 二进制文件\n文件常用操作接口介绍 标准设备文件的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } WriteString 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } Read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { fin, err := os.Open(\u0026#34;./xxx.txt\u0026#34;) //打开文件 if err != nil { fmt.Println(err) } defer fin.Close() buf := make([]byte, 1024) //开辟1024个字节的slice作为缓冲 for { n, _ := fin.Read(buf) //读文件 if n == 0 { //0表示已经到文件结束 break } fmt.Println(string(buf)) //输出读取的内容 } } 借助bufo实现按行读取 拷贝文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args //获取用户输入的所有参数 //如果用户没有输入,或参数个数不够,则调用该函数提示用户 if args == nil || len(args) != 3 { fmt.Println(\u0026#34;useage : xxx srcFile dstFile\u0026#34;) return } srcPath := args[1] //获取输入的第一个参数 dstPath := args[2] //获取输入的第二个参数 fmt.Printf(\u0026#34;srcPath = %s, dstPath = %s\\n\u0026#34;, srcPath, dstPath) if srcPath == dstPath { fmt.Println(\u0026#34;源文件和目的文件名字不能相同\u0026#34;) return } srcFile, err1 := os.Open(srcPath) //打开源文件 if err1 != nil { fmt.Println(err1) return } dstFile, err2 := os.Create(dstPath) //创建目的文件 if err2 != nil { fmt.Println(err2) return } buf := make([]byte, 1024) //切片缓冲区 for { //从源文件读取内容，n为读取文件内容的长度 n, err := srcFile.Read(buf) if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(err) break } if n == 0 { fmt.Println(\u0026#34;文件处理完毕\u0026#34;) break } //切片截取 tmp := buf[:n] //把读取的内容写入到目的文件 dstFile.Write(tmp) } //关闭文件 srcFile.Close() dstFile.Close() } 并发和并行的区别 并行是两个队列同时使用两台咖啡机\n并发就是两个队列交替使用一台咖啡机\n创建goroutine goroutine是GO的协程\n协程 比线程更小\n内部实现内存共享\n主函数就是主goroutine\n后面就是子协程 这是并发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 for { fmt.Println(\u0026#34;this is a main goroutine\u0026#34;) time.Sleep(time.Second) } } 程序起点就是主函数\n只要看到go 就开了一个新的协程\n两个任务同时操作（时间片轮转）\n在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建\n主协程先退出 主goroutine退出后，其它的工作goroutine也会自动退出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 fmt.Println(\u0026#34;main goroutine exit\u0026#34;) } 主协程先退出导致子协程来不及调用 runtime：Gosched的使用 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。\n这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { go func() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;go\u0026#34;) } }() for i := 0; i \u0026lt; 2; i++ { // 让出时间片 先让别的协议执行 它执行完 再回来执行此协程 runtime.Gosched() fmt.Println(\u0026#34;hello\u0026#34;) } } go\ngo\ngo\ngo\ngo\nhello\nhello\nruntime：Goexit的使用 调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\nddddddddddddddddd\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) return //终止此函数 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) runtime.Goexit() //终止所在协程 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\ngo func()和test()在同一个协程\nruntime：GoMAXPROCS的使用 调用 runtime.GOMAXPROCS() 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。\n1 2 3 4 5 6 7 8 9 10 func main() { //n := runtime.GOMAXPROCS(1) //打印结果：111111111111111111110000000000000000000011111... n := runtime.GOMAXPROCS(2) //打印结果：010101010101010101011001100101011010010100110... fmt.Printf(\u0026#34;n = %d\\n\u0026#34;, n) for { go fmt.Print(0) fmt.Print(1) } } 在第一次执行(runtime.GOMAXPROCS(1))时，最多同时只能有一个goroutine被执行。所以\n会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。\n在第二次执行(runtime.GOMAXPROCS(2))时，我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。\n多任务资源竞争问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } func Person1() { Printer(\u0026#34;hello\u0026#34;) } func Person2() { Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } //打印结果乱码：hwoerllldo 最终要实现同步：我打印完你才能打印 于是引出了channel\nchannel介绍 goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。\n引⽤类型 channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。\n相当于一个水管 一边放东西 一边取东西 没东西就阻塞\n可以通过make 来创建 引用类型\n1 2 make(chan Type) //等价于make(chan Type, 0) make(chan Type, capacity) 当 capacity= 0 时，channel 是无缓冲阻塞读写的，当capacity\u0026gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。\nchannel通过操作符\u0026lt;-来接收和发送数据，发送和接收数据语法：\n1 2 3 4 channel \u0026lt;- value //发送value到channel \u0026lt;-channel //接收并将其丢弃 x := \u0026lt;-channel //从channel中接收数据，并赋值给x x, ok := \u0026lt;-channel //功能同上，同时检查通道是否已关闭或者是否为空 通过channel实现同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan int) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } //person1执行完才能到person2 func Person1() { Printer(\u0026#34;hello\u0026#34;) ch \u0026lt;- 666 //给管道写数据 } func Person2() { \u0026lt;-ch //从管道取数据 接收 如果通道没有数据 就会阻塞 Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } hello\nworld\n通过channel实现同步和数据交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan string) func main() { go func() { defer fmt.Println(\u0026#34;子协程调用完毕\u0026#34;) for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;子协程 i = \u0026#34;, i) time.Sleep(time.Second) } ch \u0026lt;- \u0026#34;我是子协程 工作完毕\u0026#34; }() // 不让主协程结束 死循环 str := \u0026lt;-ch //没有数据一直阻塞 fmt.Println(\u0026#34;str = \u0026#34;, str) } 子协程 i = 0\n子协程 i = 1\n子协程调用完毕\nstr = 我是子协程 工作完毕\n无缓冲channel 无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。\n这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。\n这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。\n下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值：\n不能存储 等于没有存储箱 一旦上交数据必须接受 交换完成才会解锁goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) //无缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=0\n子协程： i = 0,\nnum = 0\n子协程正在运行[0]: len(c)=0, cap(c)=0\n子协程： i = 1,\n子协程正在运行[1]: len(c)=0, cap(c)=0\n子协程： i = 2,\nnum = 1\nnum = 2\nmain协程结束\n有缓冲channel 这个可以缓存 指定容量就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程： i = 0,\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程： i = 1,\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程： i = 2,\n子协程正在运行[2]: len(c)=3, cap(c)=3\n子协程结束\nnum = 0\nnum = 1\nnum = 2\nmain协程结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 10; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 10; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程正在运行[2]: len(c)=3, cap(c)=3\nnum = 0\nnum = 1\nnum = 2\nnum = 3\n子协程正在运行[3]: len(c)=2, cap(c)=3\n子协程正在运行[4]: len(c)=0, cap(c)=3\n子协程正在运行[5]: len(c)=1, cap(c)=3\n子协程正在运行[6]: len(c)=2, cap(c)=3\n子协程正在运行[7]: len(c)=3, cap(c)=3\nnum = 4\nnum = 5\nnum = 6\nnum = 7\nnum = 8\n子协程正在运行[8]: len(c)=0, cap(c)=3\n子协程正在运行[9]: len(c)=0, cap(c)=3\n子协程结束\nnum = 9\nmain协程结束\n关闭channel 如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 if data, ok := \u0026lt;-c; ok 那一行 close(ch) }() for { //ok为true说明channel没有关闭，为false说明管道已经关闭 if data, ok := \u0026lt;-ch; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Finished\u0026#34;) 0\n1\n2\n3\n4\nFinished\n通过range遍历channel内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 for data := range c 那一行 close(c) }() for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Finished\u0026#34;) } 单向channel 默认情况下，通道是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。\n但是，我们经常见一个通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。\n1 2 3 var ch1 chan int // ch1是一个正常的channel，不是单向的 var ch2 chan\u0026lt;- float64 // ch2是单向channel，只用于写float64数据 var ch3 \u0026lt;-chan int // ch3是单向channel，只用于读取int数据 双向channel可以隐式转换成单向的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; // only write func producer(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { out \u0026lt;- i * i } close(out) } //only read func consumer(in \u0026lt;-chan int) { for num := range in { fmt.Println(\u0026#34;num = \u0026#34;, num) } } func main() { // 创建一个双向通道 ch := make(chan int) // 生产者，生产数字 写入channel // 新开一个协程 go producer(ch) //channel传参 引用传递 // 消费者，从channel读取内容 consumer(ch) } num = 0\nnum = 1\nnum = 4\nnum = 9\nnum = 16\nnum = 25\nnum = 36\nnum = 49\nnum = 64\nnum = 81\nTimer的使用 Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) //验证time.newTimer()时间到了是否只会相应一次 func main() { timer := time.NewTimer(1 * time.Second) for { \u0026lt;-timer.C fmt.Println(\u0026#34;时间到\u0026#34;) } } func main01() { // 创建一个定时器 设置时间为2s 2s后往通道写内容 当前时间 timer := time.NewTimer(2 * time.Second) fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) //2s后会往timer.C写数据 有数据后就可以读取 t := \u0026lt;-timer.C //channel没有数据前后阻塞 fmt.Println(\u0026#34;t = \u0026#34;, t) } 时间到\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\nmain.main()\nd:/go/workspace/demo/bibao.go:14 +0x2a\nexit status 2\nTimer实现延时功能 1 2 3 4 func main(){ \u0026lt;-time.After(2*time.Second) fmt.Println(\u0026#34;时间到\u0026#34;) } 定时器停止 timer.Stop()\n定时器重置 timer.Reset(time.Second)\nTicker的使用 Ticker是一个定时触发的计时器，它会以一个间隔(interval)往channel发送一个事件(当前时间)，而channel的接收者可以以固定的时间间隔从channel中读取事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间) ticker := time.NewTicker(time.Second * 1) i := 0 go func() { for { //循环 \u0026lt;-ticker.C i++ fmt.Println(\u0026#34;i = \u0026#34;, i) if i == 5 { ticker.Stop() //停止定时器 } } }() //别忘了() //死循环，特地不让main goroutine结束 for { } } select的作用 监听channel上的数据流动方向\nselect的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。\n与switch语句可以选择任何可使用相等比较的条件相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：\n1 2 3 4 5 6 7 8 select { case \u0026lt;-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u0026lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } 在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。\n如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。\n如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：\nl 如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。\nl 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。\n通过select实现斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; // ch只写 quit只读 func fibonacci(ch chan\u0026lt;- int, quit \u0026lt;-chan bool) { x, y := 1, 1 for { // 监听channel数据流动 select { case ch \u0026lt;- x: x, y = y, x+y case flag := \u0026lt;-quit: fmt.Println(\u0026#34;flag = \u0026#34;, flag) return } } } func main() { ch := make(chan int) // 数字通信 quit := make(chan bool) //程序是否结束 // 消费者 从channel读取内容 //新建协程 go func() { for i := 0; i \u0026lt; 8; i++ { num := \u0026lt;-ch fmt.Println(\u0026#34;num = \u0026#34;, num) } //可以停止 quit \u0026lt;- true }() // 生产者 产生数字 写入channel fibonacci(ch, quit) } num = 1\nnum = 1\nnum = 2\nnum = 3\nnum = 5\nnum = 8\nnum = 13\nnum = 21\nflag = true\nselect实现的超时机制 有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { c := make(chan int) o := make(chan bool) go func() { for { select { case v := \u0026lt;-c: fmt.Println(v) case \u0026lt;-time.After(5 * time.Second): fmt.Println(\u0026#34;timeout\u0026#34;) o \u0026lt;- true break } } }() //c \u0026lt;- 666 // 注释掉，引发 timeout \u0026lt;-o } 简易TCP服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { // 监听 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } defer listener.Close() // 阻塞等待用户请求 conn, err := listener.Accept() if err != nil { fmt.Printf(\u0026#34;err = \u0026#34;, err) return } // 接收用户请求 buf := make([]byte, 1024) n, err1 := conn.Read(buf) if err1 != nil { fmt.Println(\u0026#34;err1 = \u0026#34;, err1) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf[:n])) defer conn.Close() // 关闭当前用户连接 } 简易TCP客户端 传输文件功能 发送方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) // 发送文件内容 func SendFile(path string, conn net.Conn) { //以只读方式打开文件 f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;os.Open err = \u0026#34;, err) return } defer f.Close() buf := make([]byte, 4096) // 读文件内容 读多少发多少 一点不差 for { n, err := f.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件发送完毕\u0026#34;) } else { fmt.Println(\u0026#34;f.read err = \u0026#34;, err) } return } // 发送内容 conn.Write(buf[:n]) } } func main() { // 提示输入文件 fmt.Println(\u0026#34;请输入需要传输的文件：\u0026#34;) var path string fmt.Scan(\u0026amp;path) // 获取文件名info.Name() info, err := os.Stat(path) if err != nil { fmt.Println(\u0026#34;os.Stat err = \u0026#34;, err) return } // 主动连接服务器 conn, err1 := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err1 != nil { fmt.Println(\u0026#34;net.Dial err1 = \u0026#34;, err1) return } defer conn.Close() var n int // 给接收方先发送文件名 _, err = conn.Write([]byte(info.Name())) if err != nil { fmt.Println(\u0026#34;conn.Write err = \u0026#34;, err) return } // 接收对方的回复 如果回复\u0026#34;ok\u0026#34;说明对方准备好 可以发送文件 buf := make([]byte, 1024) n, err2 := conn.Read(buf) if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } if n \u0026gt; 0 \u0026amp;\u0026amp; string(buf[:n]) == \u0026#34;ok\u0026#34; { // 发送文件内容 SendFile(path, conn) } } 接收方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func RecvFile(fileName string, conn net.Conn) { //新建文件 f, err := os.Create(fileName) if err != nil { fmt.Println(\u0026#34;os.Create err = \u0026#34;, err) return } buf := make([]byte, 1024) // 接收多少就写多少 for { n, err := conn.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) } else { fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) } return } if n == 0 { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) break } f.Write(buf[:n]) } } func main() { //监听 listennner, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listennner.Close() // 阻塞等待用户连接 conn, err1 := listennner.Accept() if err1 != nil { fmt.Println(\u0026#34;listenner accept err = \u0026#34;, err1) return } defer conn.Close() buf := make([]byte, 1024) var n int n, err2 := conn.Read(buf) //读取对方发送的文件名 if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } fileName := string(buf[:n]) // 回复\u0026#34;ok\u0026#34; conn.Write([]byte(\u0026#34;ok\u0026#34;)) // 接收文件内容 RecvFile(fileName, conn) } 并发聊天服务器 用户一上线就会给当前在线的客户端都会发送谁上线了这个信息\n原理分析：\n公共聊天室\n显示IP和说的话\n如何知道有多少个用户上线\nmap增加成员\n好处：假设有个人发送一个hello 这里有三个客户端都要发送这个hello 不管哪个人 我都遍历map 类似于广播\nmap保存这些在线用户 key-value\nkey值:ip+端口\nvalue:用户名+addr（key） + channel -\u0026gt; 结构体type Client struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Client struct { C chan string Name string Addr string // 和KEY一样 } var onlineMap map[string]Client //主要协程 处理用户连接 ：将用户加入map 2)告诉所有在线用户 谁上线了 message\u0026lt;- 有人上线了 //新开一个协程 定义一个管道 这个协程死循环 //go协程 把用户发过来的数据转发 用户发过来的数据是buf message\u0026lt;-buf //下线从map移除 var message = make(chan string) //管道用来传输信息 发送信息 传递参数cli go func(){ for{ msg := \u0026lt;-message //如果有内容 //遍历map 看有多少个成员 for _,cli:=range(onlineMap){ } } }() 广播上线 广播消息 查询在线用户 修改用户名 用户主动退出 超时处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type Client struct { C chan string //用户发送数据的管道 Name string //用户名 Addr string //网络地址 } // 保存在线用户 cliAdd ======\u0026gt;Client var Online map[string]Client var message = make(chan string) // 新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 func Manager() { //给map分配空间 Online = make(map[string]Client) for { msg := \u0026lt;-message //没有消息前阻塞 //遍历map 给每个map成员发送消息 for _, cli := range Online { cli.C \u0026lt;- msg } } } func WriteMsgToClient(cli Client, conn net.Conn) { for msg := range cli.C { conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) } } func MakeMsg(cli Client, msg string) (buf string) { buf = \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;: \u0026#34; + msg return } func HandleConn(conn net.Conn) { //处理用户连接 defer conn.Close() // 获取客户端的网络地址 cliAddr := conn.RemoteAddr().String() // 创建一个结构体 cli := Client{make(chan string), cliAddr, cliAddr} //把结构体添加到map Online[cliAddr] = cli //新开一个协程 专门给当前的客户端发送信息 go WriteMsgToClient(cli, conn) //广播某个在线 //message \u0026lt;- \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;:login\u0026#34; message \u0026lt;- MakeMsg(cli, \u0026#34;login\u0026#34;) //提示我是谁 cli.C \u0026lt;- MakeMsg(cli, \u0026#34;I am here!\u0026#34;) isQuit := make(chan bool) //对方是否主动退出 hasData := make(chan bool) //对方是否有数据发送 //新开一个协程 接收用户发送过来的数据 go func() { buf := make([]byte, 2048) for { n, err := conn.Read(buf) if n == 0 { //对方断开或者出问题 isQuit \u0026lt;- true fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) return } msg := string(buf[:n-1]) //Windows nc测试 多一个换行符 写n-1 if len(msg) == 3 \u0026amp;\u0026amp; msg == \u0026#34;who\u0026#34; { //遍历map 给当前用户发送所有成员 conn.Write([]byte(\u0026#34;user list : \\n\u0026#34;)) for _, tmp := range Online { msg = tmp.Addr + \u0026#34;:\u0026#34; + tmp.Name + \u0026#34;\\n\u0026#34; conn.Write([]byte(msg)) } } else if len(msg) \u0026gt;= 8 \u0026amp;\u0026amp; msg[:6] == \u0026#34;rename\u0026#34; { //rename|mike name := strings.Split(msg, \u0026#34;|\u0026#34;)[1] cli.Name = name Online[cliAddr] = cli conn.Write([]byte(\u0026#34;rename ok\\n\u0026#34;)) } else { //转发此内容 message \u0026lt;- MakeMsg(cli, string(msg)) } hasData \u0026lt;- true //代表 有数据 } }() for { //通过select来检测channel的流动 select { case \u0026lt;-isQuit: delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;login out\\n\u0026#34;) //广播谁下线了 return case \u0026lt;-hasData: case \u0026lt;-time.After(60 * time.Second): //60s超时 delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;time out leave out\\n\u0026#34;) //广播谁下线了 return } } } func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listener.Close() //新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 go Manager() //主协程 循环阻塞等待用户连接 for { conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;Listener.accept err = \u0026#34;, err) continue } go HandleConn(conn) //处理用户连接 } } HTTP编程 ","date":"2025-02-15T23:20:17+08:00","permalink":"https://paipai2001.github.io/p/newnewnew/","title":"Newnewnew"},{"content":"","date":"2025-02-15T17:39:44+08:00","permalink":"https://paipai2001.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://paipai2001.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://paipai2001.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://paipai2001.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://paipai2001.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://paipai2001.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://paipai2001.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://paipai2001.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://paipai2001.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://paipai2001.github.io/p/emoji-support/","title":"Emoji Support"}]