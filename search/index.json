[{"content":"GO语言学习 day01:基础类型\nday02:函数工程管理\nday03:复合类型\nday04:oop\nday05:异常文本文件处理\nday06:并发编程\nday07:网络概述\nday08:http编程\n回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; type FuncType func(int, int) int func Add(a, b int) int { return a + b } //回调函数 函数有一个参数是函数类型 这个函数就是回调函数 //计算器 可以进行四则运算 //多态，多种形态，调用同一个接口，不同的表现，从一个接口可以实现不同表现 加减乘除 // 先有想法 后面再实现功能 //可扩展性 func Calc(a, b int, fTest FuncType) (result int) { fmt.Println(\u0026#34;Calc\u0026#34;) result = fTest(a, b) //这个函数还没有实现 //result = Add(a,b)//必须先定义才能使用 return } func main() { a := Calc(1, 1, Add) fmt.Println(\u0026#34;a = \u0026#34;, a) } 匿名函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; //匿名函数 没有函数名字 f1 := func() { //:=自动推导类型 fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;str = \u0026#34;, str) } f1() //给一个函数类型起别名 type FuncType func() // 函数没有参数 没有返回值 var f2 FuncType f2 = f1 f2() //定义匿名函数 同时调用 func() { fmt.Println(\u0026#34;a = %d str = %s\u0026#34;, a, str) }() //后面的()代表调用这个匿名函数 // 带参数的匿名函数 f3 := func(i, j int) { fmt.Printf(\u0026#34;i = %d,j = %d\u0026#34;, i, j) } f3(10, 20) //匿名函数 有参有返回值 x, y := func(i, j int) (max, min int) { if i \u0026gt; j { max = i min = j } else { max = j min = i } return }(10, 20) fmt.Printf(\u0026#34;x = %d y = %d\\n\u0026#34;, x, y) } 闭包 不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { a := 10 str := \u0026#34;mike\u0026#34; func() { //闭包以引用方式捕获外部变量 a = 666 str = \u0026#34;go\u0026#34; fmt.Printf(\u0026#34;a = %d, str = %s\\n\u0026#34;, a, str) }() //()代表直接调用 fmt.Printf(\u0026#34;outside:a = %d, str = %s\\n\u0026#34;, a, str) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func test01() int { var x int //没有初始化 值为0 x++ return x * x } func main() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } 1 2 3 4 5 PS D:\\go\\workspace\\demo\u0026gt; go run bibao.go 1 1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; //函数返回值是一个匿名函数 返回一个函数类型 func test02() func() int { var x int return func() int { x++ return x * x } } func main() { //返回值为一个匿名函数 所以返回一个函数类型 通过f 调用返回的匿名函数 //它不关心这些捕获了的变量和常量是否已经超出了作用域 // 所以只要闭包还在使用它 这些变量就还会存在 f := test02() fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) fmt.Println(f()) } func test01() int { //函数被调用时，x才分配空间，才初始化为0 var x int //没有初始化 值为0 x++ return x * x //函数调用完毕，x自动释放 } func main01() { fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) fmt.Println(test01()) } defer延迟调用 1 2 3 package main import \u0026#34;fmt\u0026#34; 获取命令行参数 1 2 3 4 package main import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; 工程管理 同一个目录下：\n分文件编程 必须放在src目录\n设置gopath环境变量\n同一个目录 包名必须一样\ngo env 查看go相关环境路径\n同一个目录 调用别的文件函数 直接调用即可 无需包名引用\n不同目录下：\nsrc:main.go\nsrc/calc:calc.go\n不同目录 包名不一样\n调用不同包里面的函数 格式：包名.函数名（)\n也要import “calc”\n调用别的包函数 如果函数名字开头小写 无法调用\n必须首字母大写\n变量内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int = 10 fmt.Printf(\u0026#34;a = %d\\n\u0026#34;, a) fmt.Printf(\u0026#34;\u0026amp;a = %v\\n\u0026#34;, \u0026amp;a) //保存某个变量地址 需要指针类型 *int 保存int的地址 ** int 保存 *int地址 var p *int p = \u0026amp;a //指针变量指向谁 就把谁的地址赋值给指针变量 // fmt.Printf(\u0026#34;*p = %v, a= %v\u0026#34;, *p, a) } 不要操作没有合法指向内存 值传递和地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { *a, *b = *b, *a fmt.Printf(\u0026#34;swap:a = %d,b = %d\\n\u0026#34;, *a, *b) } func main() { a, b := 10, 20 swap(\u0026amp;a, \u0026amp;b) //变量本身传递 值传递 fmt.Printf(\u0026#34;main:a = %d,b = %d\\n\u0026#34;, a, b) } 数组array 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { // 数组同一个类型的集合 var id [50]int for i := 0; i \u0026lt; len(id); i++ { id[i] = i + 1 fmt.Printf(\u0026#34;%d\\n\u0026#34;, id[i]) } } 数组基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { var a [10]int var b [5]int fmt.Printf(\u0026#34;len(a) = %d len(b) = %d\\n\u0026#34;, len(a), len(b)) // 注意数组元素个数必须是常量 // n:= 10 // var c [n]int error non-constant array boud n // 下标可以是变量或者常量 a[0] = 1 i := 1 a[i] = 2 for i := 0; i \u0026lt; len(a); i++ { a[i] = i + 1 fmt.Printf(\u0026#34;%d\u0026#34;, a[i]) } for i, data := range a { fmt.Printf(\u0026#34;a[%d] = %d\\n\u0026#34;, i, data) } } 数组初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { //声明定义同时赋值 叫初始化 // 全部初始化 var a [5]int = [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;a = \u0026#34;, a) // b := [5]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;b = \u0026#34;, b) // 部分初始化 没有初始化的元素 自动赋值为0 c := [5]int{1, 2, 3} fmt.Println(\u0026#34;c = \u0026#34;, c) // 指定某个元素初始化 d := [5]int{2: 10, 4: 20} fmt.Println(\u0026#34;d = \u0026#34;, d) } 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func main() { var a [3][4]int k := 0 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 4; j++ { k++ a[i][j] = k fmt.Printf(\u0026#34;a[%d][%d] = %d \u0026#34;, i, j, a[i][j]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}} fmt.Println(\u0026#34;b= \u0026#34;, b) // 部分初始化 其他值为0 c := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}, {9, 10}} fmt.Println(\u0026#34;c= \u0026#34;, c) d := [3][4]int{1:{5, 6, 7, 8}} fmt.Println(\u0026#34;d= \u0026#34;, d) } 数组比较和赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { // 支持比较 只支持==或者!= 比较是不是每个元素都一样 两个数组比较 类型必须一致 a := [5]int{1, 2, 3, 4, 5} b := [5]int{1, 2, 3, 4, 5} c := [5]int{1, 2, 3} fmt.Println(\u0026#34; a == b \u0026#34;, a == b) fmt.Println(\u0026#34;a == c \u0026#34;, a == c) // 同类型的数组可以赋值 var d [5]int d = a fmt.Println(\u0026#34;d = \u0026#34;, d) } 随机数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;rand = \u0026#34;, rand.Intn(100)) //限制在100以内 } } 冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 设置种子 只需一次 // 如果种子参数一样 每次运行程序产生的随机数都一样 rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数 // 产生随机数 var a [10]int n := len(a) for i := 0; i \u0026lt; n; i++ { a[i] = rand.Intn(100) fmt.Printf(\u0026#34;%d \u0026#34;, a[i]) //限制在100以内 } fmt.Printf(\u0026#34;\\n\u0026#34;) for i := 0; i \u0026lt; n-1; i++ { for j := 0; j \u0026lt; n-i-1; j++ { if a[j] \u0026gt; a[j+1] { a[j], a[j+1] = a[j+1], a[j] } } } fmt.Printf(\u0026#34;\\n排序后:\\n\u0026#34;) for i := 0; i \u0026lt; n; i++ { fmt.Printf(\u0026#34;%v \u0026#34;, a[i]) } fmt.Printf(\u0026#34;\\n\u0026#34;) } 数组做函数参数是值拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; // 数组做函数参数 值传递 // 实参数组的每个元素给形参拷贝一份 //形参数组是实参数组的复制品 func modify(a [5]int) { a[0] = 666 fmt.Println(\u0026#34;a = \u0026#34;, a) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(a) fmt.Println(\u0026#34;a = \u0026#34;, a) } 数组指针做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; //p指向实参数组a 数组指针 // *p代表指针指向内存 也就是实参a func modify(p *[5]int) { (*p)[0] = 666 fmt.Println(\u0026#34;p = \u0026#34;, *p) } func main() { a := [5]int{1, 2, 3, 4, 5} modify(\u0026amp;a) //地址传递 fmt.Println(\u0026#34;a = \u0026#34;, a) } 切片 实现变长数组方案:需要用一个数组保存学生成绩 但是学生个数不确定\n不是真正意义的动态数组 只是一个引用类型 总是指向一个底层array\narray := [\u0026hellip;]int{10,20,30,9,0}\nslice:=array[0:3:5]\n[low:high:max]\nlow:下标起点\nhigh:下标终点\nmax:容量\n左闭右开 不包括high下标\nlen = high-low\ncap = max-low\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { a := []int{1, 2, 3, 0, 0} s := a[0:3:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) s = a[1:4:5] fmt.Println(\u0026#34;s = \u0026#34;, s) fmt.Println(\u0026#34;len(s)= \u0026#34;, len(s)) fmt.Println(\u0026#34;cap(s)= \u0026#34;, cap(s)) } 数组和切片区别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import \u0026#34;fmt\u0026#34; func main() { //自动推导类型 s1 := []int{1, 2, 3, 4} fmt.Println(\u0026#34;s1= \u0026#34;, s1) //make 格式：make(切片类型,len,cap) s2 := make([]int, 5, 10) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s2), cap(s2)) // 没有指定容量 容量和长度一样 s3 := make([]int, 5) fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s3), cap(s3)) } func main01() { //切片和数组的区别 //数组[]里面的长度是一个固定的常量 数组不能修改长度 len和cap永远都是5 a := [5]int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(a), cap(a)) // 切片 []里面为空 或者为... // 切片的长度或者容量可以不固定 s := []int{} fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) s = append(s, 11) //给切片末尾追加一个成员 fmt.Printf(\u0026#34;len = %d cap = %d\\n\u0026#34;, len(s), cap(s)) } 切片截取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { array := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := array[:] //[0:len(array):len(array)]不指定容量和长度一样 fmt.Println(\u0026#34;s1 = \u0026#34;, s1) fmt.Printf(\u0026#34;len(s1) = %d,cap(s1) = %d\\n\u0026#34;, len(s1), cap(s1)) //操作某个元素 和数组操作方式一样 data := array[0] fmt.Printf(\u0026#34;data=%v\\n\u0026#34;, data) s2 := array[3:6:7] //a[3] a[4] a[5] len = 6-3=3 cap = 7-3 = 4 fmt.Printf(\u0026#34;len(s2) = %d,cap(s2) = %d\\n\u0026#34;, len(s2), cap(s2)) s3 := array[:6] //从0开始 去6个元素 容量也是6 fmt.Println(\u0026#34;s3 = \u0026#34;, s3) fmt.Printf(\u0026#34;len(s3) = %d,cap(s3) = %d\\n\u0026#34;, len(s3), cap(s3)) s4 := array[3:] //从下标为3开始 到结尾 fmt.Println(\u0026#34;s4 = \u0026#34;, s4) fmt.Printf(\u0026#34;len(s4) = %d,cap(s4) = %d\\n\u0026#34;, len(s4), cap(s4)) } append函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { s1 := []int{} fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //在原切片末尾添加元素 s1 = append(s1, 1) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s1 = append(s1, 2, 3) fmt.Printf(\u0026#34;len(s1) = %d, cap(s1) = %d\u0026#34;, len(s1), cap(s1)) fmt.Println(\u0026#34;s1 = \u0026#34;, s1) s2 := []int{1, 2, 3} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) s2 = append(s2, 3, 4, 5) fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } 扩容特点：\n如果超过原来的容量 通常以两倍容量扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { s := make([]int, 0, 1) oldCap := cap(s) for i := 0; i \u0026lt; 8; i++ { s = append(s, i) if newCap := cap(s); oldCap \u0026lt; newCap { fmt.Printf(\u0026#34;cap:%d=====\u0026gt;%d\\n\u0026#34;, oldCap, newCap) oldCap = newCap } } } copy使用 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { srcSlice := []int{1, 2} dstSlice := []int{6, 6, 6, 6, 6} copy(dstSlice, srcSlice) fmt.Println(\u0026#34;dst = \u0026#34;, dstSlice) } dst = [1 2 6 6 6]\n切片做函数参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func test(s []int) { //切片做函数参数 s[0] = -1 fmt.Println(\u0026#34;test : \u0026#34;) for i, v := range s { fmt.Printf(\u0026#34;s[%d]=%d, \u0026#34;, i, v) //s[0]=-1, s[1]=1, s[2]=2, s[3]=3, s[4]=4, s[5]=5, s[6]=6, s[7]=7, s[8]=8, s[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} test(slice) fmt.Println(\u0026#34;main : \u0026#34;) for i, v := range slice { fmt.Printf(\u0026#34;slice[%d]=%d, \u0026#34;, i, v) //slice[0]=-1, slice[1]=1, slice[2]=2, slice[3]=3, slice[4]=4, slice[5]=5, slice[6]=6, slice[7]=7, slice[8]=8, slice[9]=9, } fmt.Println(\u0026#34;\\n\u0026#34;) } 猜数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func CreatNum(p *int) { rand.Seed(time.Now().UnixNano()) num := rand.Intn(9000) + 1000 *p = num } func GetNum(s []int, num int) { s[0] = num / 1000 s[1] = num % 1000 / 100 s[2] = num % 100 / 10 s[3] = num % 10 } func OnGame(randNum []int) { var num int for { for { fmt.Printf(\u0026#34;请输入一个四位数：\u0026#34;) fmt.Scan(\u0026amp;num) if num \u0026gt; 999 \u0026amp;\u0026amp; num \u0026lt; 10000 { break } fmt.Printf(\u0026#34;输入数字不是四位数 请重新输入：\u0026#34;) } fmt.Println(\u0026#34;num = \u0026#34;, num) keySlice := make([]int, 4) GetNum(keySlice, num) fmt.Println(\u0026#34;keyslice = \u0026#34;, keySlice) n := 0 for i := 0; i \u0026lt; 4; i++ { if randNum[i] \u0026lt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 大了一点\\n\u0026#34;, i+1) } else if randNum[i] \u0026gt; keySlice[i] { fmt.Printf(\u0026#34;第%d位 小了一点\\n\u0026#34;, i+1) } else { fmt.Printf(\u0026#34;第%d位 猜对了 要再接再厉\\n\u0026#34;, i+1) n++ } } if n == 4 { fmt.Println(\u0026#34;全部猜对啦！\u0026#34;) break } } } func main() { var randNum int //产生一个4位的随机数 CreatNum(\u0026amp;randNum) fmt.Println(\u0026#34;randNum: \u0026#34;, randNum) randSlice := make([]int, 4) GetNum(randSlice, randNum) fmt.Println(\u0026#34;randSlice = \u0026#34;, randSlice) OnGame(randSlice) //游戏 } map 键值对 字典\nmap[int]string{\n110:\u0026ldquo;string\u0026rdquo;\n111:\u0026ldquo;void\u0026rdquo;\n}\n注意是无序的 返回顺序不一定\n键值唯一 切片不能做键值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string var m1 map[int]string fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //对于map只有len,没有cap fmt.Println(\u0026#34;len = \u0026#34;, len(m1)) //可以通过make创建 可以指定长度 m2 := make(map[int]string) fmt.Println(\u0026#34;m2 = \u0026#34;, m2) fmt.Println(\u0026#34;len = \u0026#34;, len(m2)) //这个指定的长度其实是容量 m3 := make(map[int]string, 10) m3[1] = \u0026#34;mike\u0026#34; m3[2] = \u0026#34;go\u0026#34; m3[3] = \u0026#34;c++\u0026#34; fmt.Println(\u0026#34;m3 = \u0026#34;, m3) fmt.Println(\u0026#34;len = \u0026#34;, len(m3)) //初始化 键值必须是唯一的 m4 := map[int]string{1: \u0026#34;mike\u0026#34;} fmt.Println(\u0026#34;m4 = \u0026#34;, m4) fmt.Println(\u0026#34;len = \u0026#34;, len(m4)) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个变量 map[int]string m1 := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;} fmt.Println(\u0026#34;m1 = \u0026#34;, m1) //不存在直接加上 m1[3] = \u0026#34;c++\u0026#34; //存在就修改 m1[1] = \u0026#34;go\u0026#34; fmt.Println(\u0026#34;now:m1 = \u0026#34;, m1) m := map[int]string{1: \u0026#34;Mike\u0026#34;, 2: \u0026#34;yoyo\u0026#34;, 3: \u0026#34;go\u0026#34;} // 第一个返回值是key 第二个返回值是value 遍历结果是无序的 for key, value := range m { fmt.Printf(\u0026#34;%d-------------\u0026gt;%s\\n\u0026#34;, key, value) } // 如何判断一个key值是否存在 // 第一个返回值为key所对应的value 第二个返回值为key是否存在的条件 存在ok为true value, ok := m[1] if ok == true { fmt.Println(\u0026#34;m[1]= \u0026#34;, value) } else { fmt.Println(\u0026#34;key不存在\u0026#34;) } //删除map元素 fmt.Println(\u0026#34;now:m = \u0026#34;, m) delete(m, 1) //删除key=1 fmt.Println(\u0026#34;delete:m = \u0026#34;, m) } 结构体普通变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var s1 Student = Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //指定成员初始化 没有初始化的成员 自动赋值为0 s2 := Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) } s1 = {1 mike 109 18 bj}\ns2 = {0 mike 0 0 bj}\n结构体指针变量初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 顺序初始化 每个成员必须初始化 byte 输出是ascii码 var p1 *Student = \u0026amp;Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;p1 = \u0026#34;, *p1) //指定成员初始化 没有初始化的成员 自动赋值为0 p2 := \u0026amp;Student{name: \u0026#34;mike\u0026#34;, addr: \u0026#34;bj\u0026#34;} fmt.Printf(\u0026#34;p2 type is %T\u0026#34;, p2) fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } [Running] go run \u0026ldquo;d:\\go\\workspace\\demo\\bibao.go\u0026rdquo;\np1 = {1 mike 109 18 bj}\np2 type is *main.Studentp2 = \u0026amp;{0 mike 0 0 bj}\n结构体成员使用：普通变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { var s Student //操作成员 需要使用.运算符 s.id = 1 s.name = \u0026#34;mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;s = \u0026#34;, s) } s = {1 mike 109 18 bj}\n结构体成员使用：指针变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { // 1.指针有合法指向后 才操作成员 // 2.先定义一个普通结构体变量 var s Student //再定义一个指针变量 保存s的地址 var p1 *Student p1 = \u0026amp;s // 通过指针操作成员 p1.id和（*p).id完全等价 只能使用.运算符 p1.age = 1 (*p1).name = \u0026#34;mike\u0026#34; p1.sex = \u0026#39;m\u0026#39; p1.age = 18 p1.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p1 = \u0026#34;, p1) // 2.通过New申请一个结构体 p2 := new(Student) p2.id = 1 p2.name = \u0026#34;mike\u0026#34; p2.age = 18 p2.addr = \u0026#34;bj\u0026#34; fmt.Println(\u0026#34;p2 = \u0026#34;, p2) } p1 = \u0026amp;{0 mike 109 18 bj}\np2 = \u0026amp;{1 mike 0 18 bj}\n结构体比较和赋值 只能用!= ==和切片类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func main() { s1 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s2 := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} s3 := Student{2, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 == s2\u0026#34;, s1 == s2) fmt.Println(\u0026#34;s1 == s3\u0026#34;, s1 == s3) //同类型的两个结构体可以互相赋值 var tmp Student tmp = s3 fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } s1 == s2 true\ns1 == s3 false\ntmp = {2 mike 109 18 bj}\n结构体做函数参数：值传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: {666 mike 109 18 bj}\nmain: {1 mike 109 18 bj}\n结构体做函数参数：地址传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type Student struct { id int name string sex byte //字符类型 age int addr string } func test01(s *Student) { s.id = 666 fmt.Println(\u0026#34;test01: \u0026#34;, s) } func main() { s := Student{1, \u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, \u0026#34;bj\u0026#34;} test01(\u0026amp;s) //值传递 形参无法改实参 fmt.Println(\u0026#34;main: \u0026#34;, s) } test01: \u0026amp;{666 mike 109 18 bj}\nmain: {666 mike 109 18 bj}\ngo语言可见性规则验证 面向对象编程 l 封装：通过方法实现\nl 继承：通过匿名字段实现\nl 多态：通过接口实现\n匿名字段作用（继承） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { var s1 Student = Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s1 = \u0026#34;, s1) //自动推导类型 s2 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.Println(\u0026#34;s2 = \u0026#34;, s2) //%+v 显示更详细 fmt.Printf(\u0026#34;s2 = %+v\\n\u0026#34;, s2) } s1 = {{mike 109 18} 1 bj}\ns2 = {{mike 109 18} 1 bj}\ns2 = {Person:{name:mike sex:109 age:18} id:1 addr:bj}\n匿名字段初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string } func main() { //顺序初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;sz\u0026#34;} //s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz} fmt.Printf(\u0026#34;s1 = %+v\\n\u0026#34;, s1) //s2 := Student{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18, 1, \u0026#34;sz\u0026#34;} //err //部分成员初始化1 s3 := Student{Person: Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19}, id: 2} //s3 = {Person:{name:lily sex:102 age:19} id:2 addr:} fmt.Printf(\u0026#34;s3 = %+v\\n\u0026#34;, s3) //部分成员初始化2 s4 := Student{Person: Person{name: \u0026#34;tom\u0026#34;}, id: 3} //s4 = {Person:{name:tom sex:0 age:0} id:3 addr:} fmt.Printf(\u0026#34;s4 = %+v\\n\u0026#34;, s4) } s1 = {Person:{name:mike sex:109 age:18} id:1 addr:sz}\ns3 = {Person:{name:lily sex:102 age:19} id:2 addr:}\ns4 = {Person:{name:tom sex:0 age:0} id:3 addr:}\n成员操作 与结构体一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var s1 Student //变量声明 //给成员赋值 s1.name = \u0026#34;mike\u0026#34; //等价于 s1.Person.name = \u0026#34;mike\u0026#34; s1.sex = \u0026#39;m\u0026#39; s1.age = 18 s1.id = 1 s1.addr = \u0026#34;sz\u0026#34; fmt.Println(s1) //{{mike 109 18} 1 sz} var s2 Student //变量声明 s2.Person = Person{\u0026#34;lily\u0026#34;, \u0026#39;f\u0026#39;, 19} s2.id = 2 s2.addr = \u0026#34;bj\u0026#34; fmt.Println(s2) //{{lily 102 19} 2 bj} 同名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; //人 type Person struct { name string sex byte age int } //学生 type Student struct { Person // 匿名字段，那么默认Student就包含了Person的所有字段 id int addr string name string //和Person同名了 } func main() { var s Student //就近原则 如果能在本作用域找到此成员 就操作此成员 // 如果没有找到 找到继承字段 s.name = \u0026#34;Mike\u0026#34; s.sex = \u0026#39;m\u0026#39; s.age = 18 s.addr = \u0026#34;bj\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) // 显示调用 s.Person.name = \u0026#34;yoyo\u0026#34; fmt.Printf(\u0026#34;s = %+v\u0026#34;, s) } s = {Person:{name: sex:109 age:18} addr:bj name:Mike}s = {Person:{name:yoyo sex:109 age:18} addr:bj name:Mike}\n非结构体匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type mystr string //自定义类型 type Person struct { name string sex byte age int } type Student struct { Person // 匿名字段，结构体类型 int // 匿名字段，内置类型 mystr // 匿名字段，自定义类型 } func main() { //初始化 s1 := Student{Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:{name:mike sex:109 age:18} int:1 mystr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //成员的操作，打印结果：mike, m, 18, 1, bj fmt.Printf(\u0026#34;%s, %c, %d, %d, %s\\n\u0026#34;, s1.name, s1.sex, s1.age, s1.int, s1.mystr) } 结构体指针类型匿名字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Person struct { //人 name string sex byte age int } type Student struct { //学生 *Person // 匿名字段，结构体指针类型 id int addr string } func main() { //初始化 s1 := Student{\u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18}, 1, \u0026#34;bj\u0026#34;} //{Person:0xc0420023e0 id:1 addr:bj} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s1) //mike, m, 18 fmt.Printf(\u0026#34;%s, %c, %d\\n\u0026#34;, s1.name, s1.sex, s1.age) //声明变量 var s2 Student s2.Person = new(Person) //分配空间 s2.name = \u0026#34;yoyo\u0026#34; s2.sex = \u0026#39;f\u0026#39; s2.age = 20 s2.id = 2 s2.addr = \u0026#34;sz\u0026#34; //yoyo 102 20 2 20 fmt.Println(s2.name, s2.sex, s2.age, s2.id, s2.age) } 方法（封装） func(xxx Type){}绑定某种类型\n面向过程和面向对象函数区别 类似于this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; //实现两个数字相加 func Add01(a, b int) int { return a + b } // 方法：给某个类型绑定一个函数 type long int //tmp叫接受者 接受者就是传递一个参数 func (tmp long) Add02(other long) long { return tmp + other } func main() { var result int result = Add01(1, 1) fmt.Println(\u0026#34;result = \u0026#34;, result) //定义一个变量 var a long = 2 // 调用格式：变量名.函数（所需参数） r := a.Add02(3) fmt.Println(\u0026#34;r = \u0026#34;, r) //面向对象只是换了一种表现形式 } 结构体类型添加方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (tmp Person) PrintInfo() { fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) } //通过一个函数 给成员赋值 func (p *Person) SetInfo(n string, s byte, a int) { p.name = n p.sex = s p.age = a } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() var p2 Person (\u0026amp;p2).SetInfo(\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 22) p2.PrintInfo() } tmp = {mike 109 18}\ntmp = {yoyo 102 22}\n方法使用总结 原来这个接受类型不能是指针\n只要接受类型不一样 这个方法就算同名 也是不同的方法 不会出现重复定义的函数\n值语义和引用语义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type Person struct { name string sex byte age int } //指针作为接收者，引用语义 引用传递 func (p *Person) SetInfoPointer() { //给成员赋值 (*p).name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } //值作为接收者，值语义 一份拷贝 func (p Person) SetInfoValue() { //给成员赋值 p.name = \u0026#34;yoyo\u0026#34; p.sex = \u0026#39;f\u0026#39; p.age = 22 } func main() { //指针作为接收者，引用语义 p1 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p1) //函数调用前 = {mike 109 18} (\u0026amp;p1).SetInfoPointer() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p1) //函数调用后 = {yoyo 102 22} fmt.Println(\u0026#34;==========================\u0026#34;) p2 := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} //初始化 //值作为接收者，值语义 fmt.Println(\u0026#34;函数调用前 = \u0026#34;, p2) //函数调用前 = {mike 109 18} p2.SetInfoValue() fmt.Println(\u0026#34;函数调用后 = \u0026#34;, p2) //函数调用后 = {mike 109 18} } %p打印地址\n指针类型和普通类型方法集 类型的方法集是指可以被该类型的值调用的所有方法的集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //指针作为接收者，引用语义 func (p *Person) SetInfoPointer() { fmt.Println(\u0026#34;SetInfoPointer\u0026#34;) } //值作为接收者，值语义 func (p Person) SetInfoValue() { fmt.Println(\u0026#34;SetInfoValue\u0026#34;) } func main() { //结构体变量是一个指针变量 它能够调用哪些方法 这些方法就是一个集合 方法集 //p 为指针类型 p := \u0026amp;Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.SetInfoPointer() //func (p) SetInfoPointer() //内部做的转换 会先把指针p转成*p后再调用 // (*p).SetInfoValue() p.SetInfoValue() } 方法的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() } mike,m,18\nyoyo,f,20\n方法的重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } //Person定义了方法 func (tmp *Person) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d\\n\u0026#34;, tmp.name, tmp.sex, tmp.age) } // 有个学生 继承Person字段 成员和方法都继承了 type Student struct { Person // 匿名字段，那么Student包含了Person的所有字段 id int addr string } func (tmp *Student) PrintInfo() { fmt.Printf(\u0026#34;%s,%c,%d,%d,%s\\n\u0026#34;, tmp.name, tmp.sex, tmp.age, tmp.id, tmp.addr) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfo() //就近原则 先找本作用域的方法 找不到再用继承的方法 s := Student{Person{\u0026#34;yoyo\u0026#34;, \u0026#39;f\u0026#39;, 20}, 2, \u0026#34;sz\u0026#34;} s.PrintInfo() s.Person.PrintInfo() } mike,m,18\nyoyo,f,20,2,sz\nyoyo,f,20\n方法值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} p.PrintInfoPointer() //0xc0420023e0, \u0026amp;{mike 109 18} // 保存方式入口地址 pFunc1 := p.PrintInfoPointer //方法值，隐式传递 receiver 调用函数时 无需再传递接收者 pFunc1() //0xc0420023e0, \u0026amp;{mike 109 18} p.PrintInfoPointer pFunc2 := p.PrintInfoValue pFunc2() //0xc042048420, {mike 109 18} } 方法表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; type Person struct { name string sex byte age int } func (p *Person) PrintInfoPointer() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, p, p) } func (p Person) PrintInfoValue() { fmt.Printf(\u0026#34;%p, %v\\n\u0026#34;, \u0026amp;p, p) } func main() { p := Person{\u0026#34;mike\u0026#34;, \u0026#39;m\u0026#39;, 18} fmt.Printf(\u0026#34;main:%p,%v\u0026#34;, \u0026amp;p, p) // 方法值隐藏了接受者 // 方法表达式 必须显示把接受者传递过去 f := (*Person).PrintInfoPointer f(\u0026amp;p) f2 := (Person).PrintInfoValue f2(p) } 接口 关于接口函数 在 Go 语言中，接口（interface）是一种非常重要的机制，它允许你定义一组方法，而不关心具体的实现类型。通过接口，我们可以编写更加灵活和通用的代码。\nGetter 接口是一个我们自定义的接口，用于获取某些数据。它要求实现它的类型必须提供一个 Get 方法，方法的签名如下：\n1 2 3 4 5 go 复制 Get(key string) ([]byte, error) 这个方法接受一个 key 字符串作为输入，返回一个 []byte（字节切片）和一个 error（可能的错误）。\n更详细的解释 我们先从一个更简单的场景开始：假设我们需要从不同的地方获取数据，比如从内存缓存或者从文件中读取。为了实现这些操作，我们定义了一个 Getter 接口，要求每个数据获取方式都要实现 Get 方法。\n1. 定义接口 1 2 3 go复制type Getter interface { Get(key string) ([]byte, error) } 这段代码定义了一个 Getter 接口，接口中有一个 Get 方法，要求实现这个接口的类型必须有 Get 方法，返回 []byte 和 error。\n2. 实现 Getter 接口的类型 接下来，我们可以定义一个或多个类型来实现这个 Getter 接口。举个例子：\n2.1 从内存缓存中获取数据\n我们可以创建一个 MemoryCache 类型来模拟内存缓存，并实现 Getter 接口。\n1 2 3 4 5 6 7 8 9 10 go复制type MemoryCache struct { data map[string][]byte } func (m *MemoryCache) Get(key string) ([]byte, error) { if value, exists := m.data[key]; exists { return value, nil } return nil, fmt.Errorf(\u0026#34;key not found: %s\u0026#34;, key) } MemoryCache 类型包含一个 data 字段，它是一个简单的 map，存储了缓存的 key 和 value。Get 方法尝试从这个 map 中查找指定的 key，如果找到了，就返回对应的 value；如果没有找到，就返回一个错误。\n2.2 从文件中获取数据\n我们还可以创建另一个 FileCache 类型来模拟从文件中读取数据：\n1 2 3 4 5 6 7 8 9 10 11 go复制type FileCache struct { filePath string } func (f *FileCache) Get(key string) ([]byte, error) { // 假设从文件读取逻辑，这里简化处理 if key == \u0026#34;fileKey\u0026#34; { return []byte(\u0026#34;file data for key: \u0026#34; + key), nil } return nil, fmt.Errorf(\u0026#34;file not found for key: %s\u0026#34;, key) } FileCache 类型模拟从文件读取数据，Get 方法根据传入的 key 返回相应的数据。如果没有找到对应的文件数据，就返回错误。\n3. 使用接口 现在我们有了两个不同的类型：MemoryCache 和 FileCache，它们都实现了 Getter 接口。我们可以通过 Getter 接口来统一处理这两种获取数据的方式，而不需要关心具体的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 go复制func main() { // 创建内存缓存和文件缓存 memoryCache := \u0026amp;MemoryCache{data: map[string][]byte{\u0026#34;name\u0026#34;: []byte(\u0026#34;Alice\u0026#34;)}} fileCache := \u0026amp;FileCache{filePath: \u0026#34;/path/to/file\u0026#34;} // 定义一个 Getter 类型的变量 var getter Getter // 使用内存缓存获取数据 getter = memoryCache data, err := getter.Get(\u0026#34;name\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;MemoryCache data:\u0026#34;, string(data)) } // 使用文件缓存获取数据 getter = fileCache data, err = getter.Get(\u0026#34;fileKey\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) } else { fmt.Println(\u0026#34;FileCache data:\u0026#34;, string(data)) } } 解释 MemoryCache 和 FileCache 实现了 Getter 接口： MemoryCache 实现了 Get 方法，负责从内存缓存中查找数据。 FileCache 实现了 Get 方法，负责从文件中读取数据。 统一使用接口类型 Getter： 在 main 函数中，我们声明了一个 getter 变量，它的类型是 Getter（接口类型）。然后我们把它分别指向了 MemoryCache 和 FileCache 类型的实例。 这样，无论是从内存缓存还是从文件缓存获取数据，我们都通过统一的 Get 方法来操作，而不需要关心具体的数据来源。 接口让代码更具通用性和灵活性： 我们可以很容易地扩展代码，添加更多实现了 Getter 接口的类型，比如从数据库获取数据。 通过接口，我们可以在不修改其他代码的情况下，灵活地切换数据来源。 总结 接口定义了一组方法，表示某种行为或操作。在这个例子中，Getter 接口定义了 Get 方法，表示“获取数据”。 任何类型只要实现了接口要求的所有方法，就可以被认为是实现了这个接口。 接口的好处是我们可以通过接口类型来处理不同的类型（如 MemoryCache 和 FileCache），从而使代码更具扩展性和通用性。 接口类型不能将其实例化。\n不关心对象是什么类型，到底是不是鸭子，只关心行为\n1 2 3 type Humaner interface { SayHi() } 接口定义和实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } func main() { // 定义接口类型的变量 var i Humaner // 只要实现了此接口方法的类型 那么这个类型的变量（接收者）就可以给i赋值 s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} i = s i.sayhi() t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} i = t i.sayhi() var str MyStr = \u0026#34;hello str\u0026#34; i = \u0026amp;str i.sayhi() } 多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import \u0026#34;fmt\u0026#34; // 定义接口类型 type Humaner interface { // 方法 只有声明 没有实现 由别的类型（自定义类型）实现 sayhi() } type Student struct { name string id int } //Student实现了此方法 func (tmp *Student) sayhi() { fmt.Printf(\u0026#34;Student[%s,%d] say hi\\n\u0026#34;, tmp.name, tmp.id) } type Teacher struct { addr string group string } func (tmp *Teacher) sayhi() { fmt.Printf(\u0026#34;Teacher[%s,%s] say hi\\n\u0026#34;, tmp.addr, tmp.group) } type MyStr string func (tmp *MyStr) sayhi() { fmt.Printf(\u0026#34;Mystr[%s] say hi\\n\u0026#34;, *tmp) } // 定义一个普通函数 函数参数为接口类型 func WhoSayHi(i Humaner) { i.sayhi() } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 666} t := \u0026amp;Teacher{\u0026#34;bj\u0026#34;, \u0026#34;go\u0026#34;} var str MyStr = \u0026#34;hello str\u0026#34; // 调用同一函数 不同表现 多态 WhoSayHi(s) WhoSayHi(t) WhoSayHi(\u0026amp;str) } 接口继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type Humaner interface { SayHi() } type Personer interface { Humaner //这里想写了SayHi()一样 匿名字段 继承了sayhi() Sing(lyrics string) } type Student struct { //学生 name string id int } //Student实现SayHi()方法 func (tmp *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, tmp.name, tmp.score) } //Student实现Sing()方法 func (tmp *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { s := \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //定义一个接口类型 var i2 Personer i2 = s i2.SayHi() //Student[mike, 88.880000] say hi!! i2.Sing(\u0026#34;学生哥\u0026#34;) //Student sing[学生哥]!! } 接口转换 //爸爸可以变成儿子 儿子不能变成爸爸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 type Humaner interface { SayHi() } type Personer interface { Humaner //这里像写了SayHi()一样 Sing(lyrics string) } type Student struct { //学生 name string score float64 } //Student实现SayHi()方法 func (s *Student) SayHi() { fmt.Printf(\u0026#34;Student[%s, %f] say hi!!\\n\u0026#34;, s.name, s.score) } //Student实现Sing()方法 func (s *Student) Sing(lyrics string) { fmt.Printf(\u0026#34;Student sing[%s]!!\\n\u0026#34;, lyrics) } func main() { //var i1 Humaner = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} //var i2 Personer = i1 //err //Personer为超集，Humaner为子集 var i1 Personer = \u0026amp;Student{\u0026#34;mike\u0026#34;, 88.88} var i2 Humaner = i1 i2.SayHi() //Student[mike, 88.880000] say hi!! } 空接口 void *\n1 2 3 4 5 var v1 interface{} = 1 // 将int类型赋值给interface{} var v2 interface{} = \u0026#34;abc\u0026#34; // 将string类型赋值给interface{} var v3 interface{} = \u0026amp;v2 // 将*interface{}类型赋值给interface{} var v4 interface{} = struct{ X int }{1} var v5 interface{} = \u0026amp;struct{ X int }{1} 当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：\n1 2 func Printf(fmt string, args ...interface{}) func Println(args ...interface{}) 通过if实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 // an int list[1] = \u0026#34;Hello\u0026#34; // a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} //类型查询 类型断言 //第一个返回下标 第二个返回下标对应的值 element 分别是i[0] i[1] i[2] for index, element := range list { //第一个返回的值 第二个返回判断结果的真假 if value, ok := element.(int); ok == true { fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) } else if value, ok := element.(string); ok { fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) } else if value, ok := element.(Person); ok { fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) } else { fmt.Printf(\u0026#34;list[%d] is of a different type\\n\u0026#34;, index) } } /* 打印结果： list[0] is an int and its value is 1 list[1] is a string and its value is Hello list[2] is a Person and its value is [mike, 18] */ } 通过switch实现断言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Element interface{} type Person struct { name string age int } func main() { list := make([]Element, 3) list[0] = 1 //an int list[1] = \u0026#34;Hello\u0026#34; //a string list[2] = Person{\u0026#34;mike\u0026#34;, 18} for index, element := range list { switch value := element.(type) { case int: fmt.Printf(\u0026#34;list[%d] is an int and its value is %d\\n\u0026#34;, index, value) case string: fmt.Printf(\u0026#34;list[%d] is a string and its value is %s\\n\u0026#34;, index, value) case Person: fmt.Printf(\u0026#34;list[%d] is a Person and its value is [%s, %d]\\n\u0026#34;, index, value.name, value.age) default: fmt.Println(\u0026#34;list[%d] is of a different type\u0026#34;, index) } } } error接口使用（普通错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { err1 := fmt.Errorf(\u0026#34;%s\u0026#34;, \u0026#34;this is normal error\u0026#34;) fmt.Println(\u0026#34;err1 = \u0026#34;, err1) err2 := errors.New(\u0026#34;this is error2\u0026#34;) fmt.Println(\u0026#34;err2 = \u0026#34;, err2) } err1 = this is normal error\nerr2 = this is error2\nerror接口应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func MyDiv(a, b int) (result int, err error) { err = nil if b == 0 { err = errors.New(\u0026#34;分母不能为0\u0026#34;) } else { result = a / b } return } func main() { result, err := MyDiv(10, 0) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } else { fmt.Println(\u0026#34;result = \u0026#34;, result) } } 显示调用panic函数（严重错误） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb() { // fmt.Println(\u0026#34;bbbbbbbb\u0026#34;) // 显示调用 panic 导致程序中断 panic(\u0026#34;this is a panic test\u0026#34;) } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb() testc() } aaaaaaaa\npanic: this is a panic test\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:12\nmain.main()\nd:/go/workspace/demo/huidiao.go:20 +0x65\nexit status 2\n数组越界导致panic 一般不会是自己调用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\npanic: runtime error: index out of range [20] with length 10\ngoroutine 1 [running]:\nmain.testb(\u0026hellip;)\nd:/go/workspace/demo/huidiao.go:11\nmain.main()\nd:/go/workspace/demo/huidiao.go:19 +0x5d\nexit status 2\nrecover的使用 必须放在defer调用的函数中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; func testa() { fmt.Println(\u0026#34;aaaaaaaa\u0026#34;) } func testb(x int) { // recover defer func() { //recover()//可以打印错误信息 // fmt.Println(recover()) if err := recover(); err != nil { //产生panic fmt.Println(err) } }() //调用此匿名函数 var a [10]int a[x] = 111 //当x为20 数组越界 产生一个Panic } func testc() { fmt.Println(\u0026#34;cccccccc\u0026#34;) } func main() { testa() testb(20) testc() } aaaaaaaa\nruntime error: index out of range [20] with length 10\ncccccccc\n字符串操作常用函数介绍 字符串操作代码验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // Contains :hellogo 中是否包含hello 包含返回true 不包含返回false fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Contains(\u0026#34;hellogo\u0026#34;, \u0026#34;abc\u0026#34;)) // Joins 组合 s := []string{\u0026#34;abc\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;mike\u0026#34;, \u0026#34;go\u0026#34;} buf := strings.Join(s, \u0026#34;$\u0026#34;) fmt.Println(\u0026#34;buf = \u0026#34;, buf) // index 查找子串的位置 不存在返回-1 fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;hello\u0026#34;)) fmt.Println(strings.Index(\u0026#34;abcdhello\u0026#34;, \u0026#34;go\u0026#34;)) //repeat 重复多少次 buf = strings.Repeat(\u0026#34;go\u0026#34;, 3) fmt.Println(\u0026#34;buf = \u0026#34;, buf) //split 以指定的分隔符拆分 buf = \u0026#34;hello@abc@go@mike\u0026#34; tmp := strings.Split(buf, \u0026#34;@\u0026#34;) fmt.Println(\u0026#34;tmp = \u0026#34;, tmp) // Trim去掉两头的字符 buf = strings.Trim(\u0026#34; are u ok? \u0026#34;, \u0026#34; \u0026#34;) //去掉两头的空格 fmt.Printf(\u0026#34;buf = #%s#\\n\u0026#34;, buf) // Field 去掉空格 把元素放入切片中 s3 := strings.Fields(\u0026#34; are u ok? \u0026#34;) //fmt.Println(\u0026#34;s3= \u0026#34;, s3) for i, data := range s3 { fmt.Println(i, \u0026#34;,\u0026#34;, data) } } true\nfalse\nbuf = abc$hello$mike$go\n4\n-1\nbuf = gogogo\ntmp = [hello abc go mike]\nbuf = #are u ok?#\n0 , are\n1 , u\n2 , ok?\n字符串转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 转换为字符串后追加到字节数组 slice := make([]byte, 0, 1024) slice = strconv.AppendBool(slice, true) //第二个数字是要追加的数字 第三个为指定十进制方式追加 slice = strconv.AppendInt(slice, 1234, 10) slice = strconv.AppendQuote(slice, \u0026#34;abcgohello\u0026#34;) fmt.Println(\u0026#34;slice = \u0026#34;, string(slice)) //转换string再打印 // 其他类型转换为字符串 var str string str = strconv.FormatBool(false) //\u0026#39;f\u0026#39;指打印格式 以小数方式 -1指小数点后位数 （紧缩模式） 64以float64 str = strconv.FormatFloat(3.14, \u0026#39;f\u0026#39;, -1, 64) fmt.Println(\u0026#34;str = \u0026#34;, str) // 整型转字符串 str = strconv.Itoa(6666) fmt.Println(\u0026#34;str = \u0026#34;, str) // 字符串转其他类型 flag, err := strconv.ParseBool(\u0026#34;true\u0026#34;) if err == nil { fmt.Println(\u0026#34;flag = \u0026#34;, flag) } else { fmt.Println(\u0026#34;err = \u0026#34;, err) } // 字符串转换为整型 a, _ := strconv.Atoi(\u0026#34;5678\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) } slice = true1234\u0026quot;abcgohello\u0026quot;\nstr = 3.14\nstr = 6666\nflag = true\na = 5678\n正则表达式 模式匹配 关键字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { buf := \u0026#34;abc azc a7c aac 888 a9c tac\u0026#34; // 1）解释规则，它会解析正则表达式 如果成功返回*regexp 解释器 失败返回errors a开头中间任意字符 结尾c reg1 := regexp.MustCompile(`a[0-9]c`) if reg1 == nil { //解析失败 fmt.Println(\u0026#34;regexp error\u0026#34;) return } // 2）根据规则提取关键信息 -1匹配所有 1只有一个 result1 := reg1.FindAllStringSubmatch(buf, -1) fmt.Println(\u0026#34;result1 = \u0026#34;, result1) } result1 = [[a7c] [a9c]]\nJSON介绍 通过结构体生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 type IT struct { Company string Subjects []string IsOk bool Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 buf, err := json.Marshal(s) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\u0026ldquo;Company\u0026rdquo;:\u0026ldquo;itcast\u0026rdquo;,\u0026ldquo;Subjects\u0026rdquo;:[\u0026ldquo;Go\u0026rdquo;,\u0026ldquo;C++\u0026rdquo;,\u0026ldquo;Python\u0026rdquo;,\u0026ldquo;Test\u0026rdquo;],\u0026ldquo;IsOk\u0026rdquo;:true,\u0026ldquo;Price\u0026rdquo;:888.888}\n格式化编码：\nbuf, err := json.MarshalIndent(s, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) //格式化编码\n输出：\nbuf = {\n\u0026ldquo;Company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;Subjects\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: true,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\nstruct_tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) // 成员变量名首字母必须大写 否则无法使用 // type IT struct { // Company string // Subjects []string // IsOk bool // Price float64 // } type IT struct { Company string `json:\u0026#34;company\u0026#34;` // 此字段不会输出到屏幕 Subjects []string `json:\u0026#34;subject\u0026#34;` // 二次编码 IsOk bool `json:\u0026#34;,string\u0026#34;` // bool转换成string Price float64 } func main() { // 定义一个结构体变量 同时初始化 s := IT{\u0026#34;itcast\u0026#34;, []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;}, true, 888.888} //编码 根据内容生成json文本 // buf, err := json.Marshal(s) buf, err := json.MarshalIndent(s, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) //格式化编码 if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf)) } buf = {\n\u0026ldquo;company\u0026rdquo;: \u0026ldquo;itcast\u0026rdquo;,\n\u0026ldquo;subject\u0026rdquo;: [\n\u0026ldquo;Go\u0026rdquo;,\n\u0026ldquo;C++\u0026rdquo;,\n\u0026ldquo;Python\u0026rdquo;,\n\u0026ldquo;Test\u0026rdquo;\n],\n\u0026ldquo;IsOk\u0026rdquo;: \u0026ldquo;true\u0026rdquo;,\n\u0026ldquo;Price\u0026rdquo;: 888.888\n}\n通过map生成json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //创建一个map m := make(map[string]interface{}, 4) m[\u0026#34;company\u0026#34;] = \u0026#34;itcast\u0026#34; m[\u0026#34;subject\u0026#34;] = []string{\u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34;} m[\u0026#34;isok\u0026#34;] = true m[\u0026#34;price\u0026#34;] = 666.666 //编码成JSON result, err := json.Marshal(m) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) } fmt.Println(\u0026#34;result = \u0026#34;, string(result)) } json解析到结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type IT struct { Company string `json:\u0026#34;company\u0026#34;` Subjects []string `json:\u0026#34;subjects\u0026#34;` IsOk bool `json:\u0026#34;isok\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t IT //定义一个结构体变量 err := json.Unmarshal([]byte(jsonBuf), \u0026amp;t) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //运行结果：{itcast [Go C++ Python Test] true 666.666} //只想要Subjects字段 type IT2 struct { Subjects []string `json:\u0026#34;subjects\u0026#34;` } var t2 IT2 err = json.Unmarshal(jsonBuf, \u0026amp;t2) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t2) //运行结果：{[Go C++ Python Test]} } json解析到map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { jsonBuf := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) //创建一个map m := make(map[string]interface{}) err := json.Unmarshal([]byte(jsonBuf), \u0026amp;m) //第二个参数要地址传递 if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Printf(\u0026#34;m = %+v\\n\u0026#34;, m) // var str string // str = string(m[\u0026#34;company\u0026#34;])//err 无法转换 //fmt.Println(\u0026#34;str = \u0026#34;,str) //这是错误的 //类型断言 for key, value := range m { fmt.Printf(\u0026#34;%v ---------------\u0026gt; %v\\n\u0026#34;, key, value) if key == \u0026#34;company\u0026#34; { str := value fmt.Println(\u0026#34;str = \u0026#34;, str) } } } func main() { b := []byte(`{ \u0026#34;company\u0026#34;: \u0026#34;itcast\u0026#34;, \u0026#34;subjects\u0026#34;: [ \u0026#34;Go\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Test\u0026#34; ], \u0026#34;isok\u0026#34;: true, \u0026#34;price\u0026#34;: 666.666 }`) var t interface{} err := json.Unmarshal(b, \u0026amp;t) if err != nil { fmt.Println(\u0026#34;json err:\u0026#34;, err) } fmt.Println(t) //使用断言判断类型 m := t.(map[string]interface{}) for k, v := range m { switch vv := v.(type) { case string: fmt.Println(k, \u0026#34;is string\u0026#34;, vv) case int: fmt.Println(k, \u0026#34;is int\u0026#34;, vv) case float64: fmt.Println(k, \u0026#34;is float64\u0026#34;, vv) case bool: fmt.Println(k, \u0026#34;is bool\u0026#34;, vv) case []interface{}: fmt.Println(k, \u0026#34;is an array:\u0026#34;) for i, u := range vv { fmt.Println(i, u) } default: fmt.Println(k, \u0026#34;is of a type I don\u0026#39;t know how to handle\u0026#34;) } } } 文件分类和为什么需要文件 设备文件：屏幕（标准输出设备）\n​\tfmt.println() 往标准输出设备写内容\n键盘（标准输入设备）\n​\tfmt.Scanf()往标准输入设备读取内容\n磁盘文件：放在存储设备上的文件\n​\t文本文件 二进制文件\n文件常用操作接口介绍 标准设备文件的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } WriteString 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //os指的是当前系统 fout, err := os.Create(\u0026#34;./xxx.txt\u0026#34;) //新建文件 //fout, err := os.OpenFile(\u0026#34;./xxx.txt\u0026#34;, os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer fout.Close() //main函数结束前， 关闭文件 for i := 0; i \u0026lt; 5; i++ { outstr := fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, \u0026#34;Hello go\u0026#34;, i) fout.WriteString(outstr) //写入string信息到文件 fout.Write([]byte(\u0026#34;abcd\\n\u0026#34;)) //写入byte类型的信息到文件 } } Read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { fin, err := os.Open(\u0026#34;./xxx.txt\u0026#34;) //打开文件 if err != nil { fmt.Println(err) } defer fin.Close() buf := make([]byte, 1024) //开辟1024个字节的slice作为缓冲 for { n, _ := fin.Read(buf) //读文件 if n == 0 { //0表示已经到文件结束 break } fmt.Println(string(buf)) //输出读取的内容 } } 借助bufo实现按行读取 拷贝文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { args := os.Args //获取用户输入的所有参数 //如果用户没有输入,或参数个数不够,则调用该函数提示用户 if args == nil || len(args) != 3 { fmt.Println(\u0026#34;useage : xxx srcFile dstFile\u0026#34;) return } srcPath := args[1] //获取输入的第一个参数 dstPath := args[2] //获取输入的第二个参数 fmt.Printf(\u0026#34;srcPath = %s, dstPath = %s\\n\u0026#34;, srcPath, dstPath) if srcPath == dstPath { fmt.Println(\u0026#34;源文件和目的文件名字不能相同\u0026#34;) return } srcFile, err1 := os.Open(srcPath) //打开源文件 if err1 != nil { fmt.Println(err1) return } dstFile, err2 := os.Create(dstPath) //创建目的文件 if err2 != nil { fmt.Println(err2) return } buf := make([]byte, 1024) //切片缓冲区 for { //从源文件读取内容，n为读取文件内容的长度 n, err := srcFile.Read(buf) if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(err) break } if n == 0 { fmt.Println(\u0026#34;文件处理完毕\u0026#34;) break } //切片截取 tmp := buf[:n] //把读取的内容写入到目的文件 dstFile.Write(tmp) } //关闭文件 srcFile.Close() dstFile.Close() } 并发和并行的区别 并行是两个队列同时使用两台咖啡机\n并发就是两个队列交替使用一台咖啡机\n创建goroutine goroutine是GO的协程\n协程 比线程更小\n内部实现内存共享\n主函数就是主goroutine\n后面就是子协程 这是并发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 for { fmt.Println(\u0026#34;this is a main goroutine\u0026#34;) time.Sleep(time.Second) } } 程序起点就是主函数\n只要看到go 就开了一个新的协程\n两个任务同时操作（时间片轮转）\n在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建\n主协程先退出 主goroutine退出后，其它的工作goroutine也会自动退出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { for { fmt.Println(\u0026#34;this is a newTask\u0026#34;) time.Sleep(time.Second) } } func main() { go newTask() //新建一个协程 新建一个任务 fmt.Println(\u0026#34;main goroutine exit\u0026#34;) } 主协程先退出导致子协程来不及调用 runtime：Gosched的使用 用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。\n这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { go func() { for i := 0; i \u0026lt; 5; i++ { fmt.Println(\u0026#34;go\u0026#34;) } }() for i := 0; i \u0026lt; 2; i++ { // 让出时间片 先让别的协议执行 它执行完 再回来执行此协程 runtime.Gosched() fmt.Println(\u0026#34;hello\u0026#34;) } } go\ngo\ngo\ngo\ngo\nhello\nhello\nruntime：Goexit的使用 调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\nddddddddddddddddd\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) return //终止此函数 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\nbbbbbbbbbbbb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func test() { defer fmt.Println(\u0026#34;cccccccccccccccccc\u0026#34;) runtime.Goexit() //终止所在协程 fmt.Println(\u0026#34;ddddddddddddddddd\u0026#34;) } func main() { //特地写一个死循环 目的不让主协程结束 go func() { fmt.Println(\u0026#34;aaaaaaaaaa\u0026#34;) //调用别的函数 test() fmt.Println(\u0026#34;bbbbbbbbbbbb\u0026#34;) }() for { } } aaaaaaaaaa\ncccccccccccccccccc\ngo func()和test()在同一个协程\nruntime：GoMAXPROCS的使用 调用 runtime.GOMAXPROCS() 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。\n1 2 3 4 5 6 7 8 9 10 func main() { //n := runtime.GOMAXPROCS(1) //打印结果：111111111111111111110000000000000000000011111... n := runtime.GOMAXPROCS(2) //打印结果：010101010101010101011001100101011010010100110... fmt.Printf(\u0026#34;n = %d\\n\u0026#34;, n) for { go fmt.Print(0) fmt.Print(1) } } 在第一次执行(runtime.GOMAXPROCS(1))时，最多同时只能有一个goroutine被执行。所以\n会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。\n在第二次执行(runtime.GOMAXPROCS(2))时，我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。\n多任务资源竞争问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } func Person1() { Printer(\u0026#34;hello\u0026#34;) } func Person2() { Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } //打印结果乱码：hwoerllldo 最终要实现同步：我打印完你才能打印 于是引出了channel\nchannel介绍 goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。\n引⽤类型 channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。\n相当于一个水管 一边放东西 一边取东西 没东西就阻塞\n可以通过make 来创建 引用类型\n1 2 make(chan Type) //等价于make(chan Type, 0) make(chan Type, capacity) 当 capacity= 0 时，channel 是无缓冲阻塞读写的，当capacity\u0026gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。\nchannel通过操作符\u0026lt;-来接收和发送数据，发送和接收数据语法：\n1 2 3 4 channel \u0026lt;- value //发送value到channel \u0026lt;-channel //接收并将其丢弃 x := \u0026lt;-channel //从channel中接收数据，并赋值给x x, ok := \u0026lt;-channel //功能同上，同时检查通道是否已关闭或者是否为空 通过channel实现同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan int) // 定义一个打印机 参数为字符串 按照每个字符打印 // 打印机属于公共资源 func Printer(str string) { for _, data := range str { fmt.Printf(\u0026#34;%c\u0026#34;, data) time.Sleep(time.Second) } fmt.Printf(\u0026#34;\\n\u0026#34;) } //person1执行完才能到person2 func Person1() { Printer(\u0026#34;hello\u0026#34;) ch \u0026lt;- 666 //给管道写数据 } func Person2() { \u0026lt;-ch //从管道取数据 接收 如果通道没有数据 就会阻塞 Printer(\u0026#34;world\u0026#34;) } func main() { // 新建两个协程 两个人 同时使用打印机 go Person1() go Person2() // 不让主协程结束 死循环 for { } } hello\nworld\n通过channel实现同步和数据交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 全局变量 创建一个channel var ch = make(chan string) func main() { go func() { defer fmt.Println(\u0026#34;子协程调用完毕\u0026#34;) for i := 0; i \u0026lt; 2; i++ { fmt.Println(\u0026#34;子协程 i = \u0026#34;, i) time.Sleep(time.Second) } ch \u0026lt;- \u0026#34;我是子协程 工作完毕\u0026#34; }() // 不让主协程结束 死循环 str := \u0026lt;-ch //没有数据一直阻塞 fmt.Println(\u0026#34;str = \u0026#34;, str) } 子协程 i = 0\n子协程 i = 1\n子协程调用完毕\nstr = 我是子协程 工作完毕\n无缓冲channel 无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。\n这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。\n这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。\n下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值：\n不能存储 等于没有存储箱 一旦上交数据必须接受 交换完成才会解锁goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) //无缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=0\n子协程： i = 0,\nnum = 0\n子协程正在运行[0]: len(c)=0, cap(c)=0\n子协程： i = 1,\n子协程正在运行[1]: len(c)=0, cap(c)=0\n子协程： i = 2,\nnum = 1\nnum = 2\nmain协程结束\n有缓冲channel 这个可以缓存 指定容量就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 3; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程： i = 0,\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程： i = 1,\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程： i = 2,\n子协程正在运行[2]: len(c)=3, cap(c)=3\n子协程结束\nnum = 0\nnum = 1\nnum = 2\nmain协程结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int, 3) //有缓冲的通道 //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小 fmt.Printf(\u0026#34;len(c)=%d, cap(c)=%d\\n\u0026#34;, len(ch), cap(ch)) go func() { defer fmt.Println(\u0026#34;子协程结束\u0026#34;) for i := 0; i \u0026lt; 10; i++ { //fmt.Printf(\u0026#34;子协程： i = %d,\\n\u0026#34;, i) ch \u0026lt;- i fmt.Printf(\u0026#34;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\\n\u0026#34;, i, len(ch), cap(ch)) } }() time.Sleep(2 * time.Second) //延时2s for i := 0; i \u0026lt; 10; i++ { num := \u0026lt;-ch //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main协程结束\u0026#34;) } len(c)=0, cap(c)=3\n子协程正在运行[0]: len(c)=1, cap(c)=3\n子协程正在运行[1]: len(c)=2, cap(c)=3\n子协程正在运行[2]: len(c)=3, cap(c)=3\nnum = 0\nnum = 1\nnum = 2\nnum = 3\n子协程正在运行[3]: len(c)=2, cap(c)=3\n子协程正在运行[4]: len(c)=0, cap(c)=3\n子协程正在运行[5]: len(c)=1, cap(c)=3\n子协程正在运行[6]: len(c)=2, cap(c)=3\n子协程正在运行[7]: len(c)=3, cap(c)=3\nnum = 4\nnum = 5\nnum = 6\nnum = 7\nnum = 8\n子协程正在运行[8]: len(c)=0, cap(c)=3\n子协程正在运行[9]: len(c)=0, cap(c)=3\n子协程结束\nnum = 9\nmain协程结束\n关闭channel 如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 if data, ok := \u0026lt;-c; ok 那一行 close(ch) }() for { //ok为true说明channel没有关闭，为false说明管道已经关闭 if data, ok := \u0026lt;-ch; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Finished\u0026#34;) 0\n1\n2\n3\n4\nFinished\n通过range遍历channel内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } //把 close(c) 注释掉，程序会一直阻塞在 for data := range c 那一行 close(c) }() for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Finished\u0026#34;) } 单向channel 默认情况下，通道是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。\n但是，我们经常见一个通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。\n1 2 3 var ch1 chan int // ch1是一个正常的channel，不是单向的 var ch2 chan\u0026lt;- float64 // ch2是单向channel，只用于写float64数据 var ch3 \u0026lt;-chan int // ch3是单向channel，只用于读取int数据 双向channel可以隐式转换成单向的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; // only write func producer(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { out \u0026lt;- i * i } close(out) } //only read func consumer(in \u0026lt;-chan int) { for num := range in { fmt.Println(\u0026#34;num = \u0026#34;, num) } } func main() { // 创建一个双向通道 ch := make(chan int) // 生产者，生产数字 写入channel // 新开一个协程 go producer(ch) //channel传参 引用传递 // 消费者，从channel读取内容 consumer(ch) } num = 0\nnum = 1\nnum = 4\nnum = 9\nnum = 16\nnum = 25\nnum = 36\nnum = 49\nnum = 64\nnum = 81\nTimer的使用 Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) //验证time.newTimer()时间到了是否只会相应一次 func main() { timer := time.NewTimer(1 * time.Second) for { \u0026lt;-timer.C fmt.Println(\u0026#34;时间到\u0026#34;) } } func main01() { // 创建一个定时器 设置时间为2s 2s后往通道写内容 当前时间 timer := time.NewTimer(2 * time.Second) fmt.Println(\u0026#34;当前时间：\u0026#34;, time.Now()) //2s后会往timer.C写数据 有数据后就可以读取 t := \u0026lt;-timer.C //channel没有数据前后阻塞 fmt.Println(\u0026#34;t = \u0026#34;, t) } 时间到\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\nmain.main()\nd:/go/workspace/demo/bibao.go:14 +0x2a\nexit status 2\nTimer实现延时功能 1 2 3 4 func main(){ \u0026lt;-time.After(2*time.Second) fmt.Println(\u0026#34;时间到\u0026#34;) } 定时器停止 timer.Stop()\n定时器重置 timer.Reset(time.Second)\nTicker的使用 Ticker是一个定时触发的计时器，它会以一个间隔(interval)往channel发送一个事件(当前时间)，而channel的接收者可以以固定的时间间隔从channel中读取事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间) ticker := time.NewTicker(time.Second * 1) i := 0 go func() { for { //循环 \u0026lt;-ticker.C i++ fmt.Println(\u0026#34;i = \u0026#34;, i) if i == 5 { ticker.Stop() //停止定时器 } } }() //别忘了() //死循环，特地不让main goroutine结束 for { } } select的作用 监听channel上的数据流动方向\nselect的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。\n与switch语句可以选择任何可使用相等比较的条件相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：\n1 2 3 4 5 6 7 8 select { case \u0026lt;-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u0026lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } 在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。\n如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。\n如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：\nl 如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。\nl 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。\n通过select实现斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; // ch只写 quit只读 func fibonacci(ch chan\u0026lt;- int, quit \u0026lt;-chan bool) { x, y := 1, 1 for { // 监听channel数据流动 select { case ch \u0026lt;- x: x, y = y, x+y case flag := \u0026lt;-quit: fmt.Println(\u0026#34;flag = \u0026#34;, flag) return } } } func main() { ch := make(chan int) // 数字通信 quit := make(chan bool) //程序是否结束 // 消费者 从channel读取内容 //新建协程 go func() { for i := 0; i \u0026lt; 8; i++ { num := \u0026lt;-ch fmt.Println(\u0026#34;num = \u0026#34;, num) } //可以停止 quit \u0026lt;- true }() // 生产者 产生数字 写入channel fibonacci(ch, quit) } num = 1\nnum = 1\nnum = 2\nnum = 3\nnum = 5\nnum = 8\nnum = 13\nnum = 21\nflag = true\nselect实现的超时机制 有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func main() { c := make(chan int) o := make(chan bool) go func() { for { select { case v := \u0026lt;-c: fmt.Println(v) case \u0026lt;-time.After(5 * time.Second): fmt.Println(\u0026#34;timeout\u0026#34;) o \u0026lt;- true break } } }() //c \u0026lt;- 666 // 注释掉，引发 timeout \u0026lt;-o } 简易TCP服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { // 监听 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;err = \u0026#34;, err) return } defer listener.Close() // 阻塞等待用户请求 conn, err := listener.Accept() if err != nil { fmt.Printf(\u0026#34;err = \u0026#34;, err) return } // 接收用户请求 buf := make([]byte, 1024) n, err1 := conn.Read(buf) if err1 != nil { fmt.Println(\u0026#34;err1 = \u0026#34;, err1) return } fmt.Println(\u0026#34;buf = \u0026#34;, string(buf[:n])) defer conn.Close() // 关闭当前用户连接 } 简易TCP客户端 传输文件功能 发送方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) // 发送文件内容 func SendFile(path string, conn net.Conn) { //以只读方式打开文件 f, err := os.Open(path) if err != nil { fmt.Println(\u0026#34;os.Open err = \u0026#34;, err) return } defer f.Close() buf := make([]byte, 4096) // 读文件内容 读多少发多少 一点不差 for { n, err := f.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件发送完毕\u0026#34;) } else { fmt.Println(\u0026#34;f.read err = \u0026#34;, err) } return } // 发送内容 conn.Write(buf[:n]) } } func main() { // 提示输入文件 fmt.Println(\u0026#34;请输入需要传输的文件：\u0026#34;) var path string fmt.Scan(\u0026amp;path) // 获取文件名info.Name() info, err := os.Stat(path) if err != nil { fmt.Println(\u0026#34;os.Stat err = \u0026#34;, err) return } // 主动连接服务器 conn, err1 := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err1 != nil { fmt.Println(\u0026#34;net.Dial err1 = \u0026#34;, err1) return } defer conn.Close() var n int // 给接收方先发送文件名 _, err = conn.Write([]byte(info.Name())) if err != nil { fmt.Println(\u0026#34;conn.Write err = \u0026#34;, err) return } // 接收对方的回复 如果回复\u0026#34;ok\u0026#34;说明对方准备好 可以发送文件 buf := make([]byte, 1024) n, err2 := conn.Read(buf) if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } if n \u0026gt; 0 \u0026amp;\u0026amp; string(buf[:n]) == \u0026#34;ok\u0026#34; { // 发送文件内容 SendFile(path, conn) } } 接收方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func RecvFile(fileName string, conn net.Conn) { //新建文件 f, err := os.Create(fileName) if err != nil { fmt.Println(\u0026#34;os.Create err = \u0026#34;, err) return } buf := make([]byte, 1024) // 接收多少就写多少 for { n, err := conn.Read(buf) if err != nil { if err == io.EOF { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) } else { fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) } return } if n == 0 { fmt.Println(\u0026#34;文件接收完毕\u0026#34;) break } f.Write(buf[:n]) } } func main() { //监听 listennner, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listennner.Close() // 阻塞等待用户连接 conn, err1 := listennner.Accept() if err1 != nil { fmt.Println(\u0026#34;listenner accept err = \u0026#34;, err1) return } defer conn.Close() buf := make([]byte, 1024) var n int n, err2 := conn.Read(buf) //读取对方发送的文件名 if err2 != nil { fmt.Println(\u0026#34;conn.Read err2 = \u0026#34;, err2) return } fileName := string(buf[:n]) // 回复\u0026#34;ok\u0026#34; conn.Write([]byte(\u0026#34;ok\u0026#34;)) // 接收文件内容 RecvFile(fileName, conn) } 并发聊天服务器 用户一上线就会给当前在线的客户端都会发送谁上线了这个信息\n原理分析：\n公共聊天室\n显示IP和说的话\n如何知道有多少个用户上线\nmap增加成员\n好处：假设有个人发送一个hello 这里有三个客户端都要发送这个hello 不管哪个人 我都遍历map 类似于广播\nmap保存这些在线用户 key-value\nkey值:ip+端口\nvalue:用户名+addr（key） + channel -\u0026gt; 结构体type Client struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Client struct { C chan string Name string Addr string // 和KEY一样 } var onlineMap map[string]Client //主要协程 处理用户连接 ：将用户加入map 2)告诉所有在线用户 谁上线了 message\u0026lt;- 有人上线了 //新开一个协程 定义一个管道 这个协程死循环 //go协程 把用户发过来的数据转发 用户发过来的数据是buf message\u0026lt;-buf //下线从map移除 var message = make(chan string) //管道用来传输信息 发送信息 传递参数cli go func(){ for{ msg := \u0026lt;-message //如果有内容 //遍历map 看有多少个成员 for _,cli:=range(onlineMap){ } } }() 广播上线 广播消息 查询在线用户 修改用户名 用户主动退出 超时处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type Client struct { C chan string //用户发送数据的管道 Name string //用户名 Addr string //网络地址 } // 保存在线用户 cliAdd ======\u0026gt;Client var Online map[string]Client var message = make(chan string) // 新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 func Manager() { //给map分配空间 Online = make(map[string]Client) for { msg := \u0026lt;-message //没有消息前阻塞 //遍历map 给每个map成员发送消息 for _, cli := range Online { cli.C \u0026lt;- msg } } } func WriteMsgToClient(cli Client, conn net.Conn) { for msg := range cli.C { conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) } } func MakeMsg(cli Client, msg string) (buf string) { buf = \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;: \u0026#34; + msg return } func HandleConn(conn net.Conn) { //处理用户连接 defer conn.Close() // 获取客户端的网络地址 cliAddr := conn.RemoteAddr().String() // 创建一个结构体 cli := Client{make(chan string), cliAddr, cliAddr} //把结构体添加到map Online[cliAddr] = cli //新开一个协程 专门给当前的客户端发送信息 go WriteMsgToClient(cli, conn) //广播某个在线 //message \u0026lt;- \u0026#34;[\u0026#34; + cli.Addr + \u0026#34;]\u0026#34; + cli.Name + \u0026#34;:login\u0026#34; message \u0026lt;- MakeMsg(cli, \u0026#34;login\u0026#34;) //提示我是谁 cli.C \u0026lt;- MakeMsg(cli, \u0026#34;I am here!\u0026#34;) isQuit := make(chan bool) //对方是否主动退出 hasData := make(chan bool) //对方是否有数据发送 //新开一个协程 接收用户发送过来的数据 go func() { buf := make([]byte, 2048) for { n, err := conn.Read(buf) if n == 0 { //对方断开或者出问题 isQuit \u0026lt;- true fmt.Println(\u0026#34;conn.Read err = \u0026#34;, err) return } msg := string(buf[:n-1]) //Windows nc测试 多一个换行符 写n-1 if len(msg) == 3 \u0026amp;\u0026amp; msg == \u0026#34;who\u0026#34; { //遍历map 给当前用户发送所有成员 conn.Write([]byte(\u0026#34;user list : \\n\u0026#34;)) for _, tmp := range Online { msg = tmp.Addr + \u0026#34;:\u0026#34; + tmp.Name + \u0026#34;\\n\u0026#34; conn.Write([]byte(msg)) } } else if len(msg) \u0026gt;= 8 \u0026amp;\u0026amp; msg[:6] == \u0026#34;rename\u0026#34; { //rename|mike name := strings.Split(msg, \u0026#34;|\u0026#34;)[1] cli.Name = name Online[cliAddr] = cli conn.Write([]byte(\u0026#34;rename ok\\n\u0026#34;)) } else { //转发此内容 message \u0026lt;- MakeMsg(cli, string(msg)) } hasData \u0026lt;- true //代表 有数据 } }() for { //通过select来检测channel的流动 select { case \u0026lt;-isQuit: delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;login out\\n\u0026#34;) //广播谁下线了 return case \u0026lt;-hasData: case \u0026lt;-time.After(60 * time.Second): //60s超时 delete(Online, cliAddr) //当前用户从map移除 message \u0026lt;- MakeMsg(cli, \u0026#34;time out leave out\\n\u0026#34;) //广播谁下线了 return } } } func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:8000\u0026#34;) if err != nil { fmt.Println(\u0026#34;net.Listen err = \u0026#34;, err) return } defer listener.Close() //新开一个协程 来转发消息 只要有消息来了 遍历map 给map每个成员都发送消息 go Manager() //主协程 循环阻塞等待用户连接 for { conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;Listener.accept err = \u0026#34;, err) continue } go HandleConn(conn) //处理用户连接 } } HTTP编程 ","date":"2025-02-15T23:20:17+08:00","permalink":"https://paipai2001.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/","title":"Go语言学习"},{"content":"hot100 哈希表 49. 字母异位词分组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;result; unordered_map\u0026lt;string,vector\u0026lt;string\u0026gt;\u0026gt; map; for(auto \u0026amp; s : strs){ string sorted_str = s; ranges::sort(sorted_str); map[sorted_str].push_back(s); } result.reserve(map.size()); //扩充空间 for(auto \u0026amp; [_,value] :map){ //假设键值对的写法 result.push_back(value); } return result; } }; 128. 最长连续序列 - 力扣（LeetCode）\n把标准答案po在下面了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; st; for(int n: nums) st.insert(n); int ans = 0; for(int i: st){ // 假如一个数在哈希表中存在比他小的，那么它不是可以作为开头的数字 if(i != INT_MIN \u0026amp;\u0026amp; st.count(i-1)){ continue; } int cnt = 1; while(i!=INT_MAX \u0026amp;\u0026amp; st.count(i+1)){ cnt ++; i++; } ans = max(ans, cnt); } return ans; } }; count是一个存在或者不存在的函数 存在返回1 不存在返回0\n而i直接遍历set容器中的所有元素\nset不会重复插入元素 意味着元素不重复\n双指针 283. 移动零 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0; int j = 0; while(j \u0026lt; nums.size()){ if(nums[j] != 0){ swap(nums[i],nums[j]); i++; //i永远指向第一个为0的数组元素 } j++; //j永远指向第一个不为0的元素 } } }; 11. 盛最多水的容器 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { // 这题不允许移动数的位置 // 两个数组索引的差乘上两个数之间更低的高度的最大值 // 理解思路 就是两个指针分别指向数组的起点和终点 //每次移动数字小的 因为数字大的你已经没机会再找到比它更大的容量 int left = 0,right = height.size()-1; int maxArea = 0; while(left \u0026lt; right){ int max_water = min(height[left],height[right]) * (right-left); if(max_water \u0026gt;maxArea)maxArea = max_water; if(height[left] \u0026lt; height[right])left++; else right--; } return maxArea; } }; 15. 三数之和 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { //这个去重逻辑要注意 //先对数组进行排序 sort(nums.begin(),nums.end()); int left,right; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;result; //i指向的是固定要加进去的元素 只会向右移动 不向左 for(int i = 0;i \u0026lt; nums.size();i++){ if(nums[i] \u0026gt; 0)return result; //进入去重 if(i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1])continue; left = i+1; right = nums.size()-1; while(left \u0026lt; right){ if(nums[left]+nums[right]+nums[i] \u0026gt; 0) right--; else if(nums[left]+ nums[right]+nums[i] \u0026lt; 0)left++; else{ //找到了 result.push_back(vector\u0026lt;int\u0026gt;{nums[left],nums[i],nums[right]}); while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right-1]) right--; //找到后还要继续移动两个指针 //之前用的写法是哈希表 left++; right--; } } } return result; } }; 滑动窗口 滑动窗口题目:\n无重复字符的最长子串\n串联所有单词的子串\n最小覆盖子串\n至多包含两个不同字符的最长子串\n长度最小的子数组\n滑动窗口最大值\n字符串的排列\n最小区间\n最小窗口子序列\n不熟悉的情况下多练习：\n3. 无重复字符的最长子串 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int lengthOfLongestSubstring(string s) { if(s.size() == 0)return 0; if(s.size() == 1)return 1; unordered_set\u0026lt;char\u0026gt; set; int left = 0; int result = 0; for(int i = 0;i \u0026lt; s.size();i++){ while(set.find(s[i]) != set.end()){ //这里逻辑出了问题：应该是往后遍历元素的时候判断是否在set集合当中 // 而不是看最左的元素 这一直找肯定是找不到的 //printf(\u0026#34;i = %d\\n\u0026#34;,i); //printf(\u0026#34;result = %d\\n\u0026#34;,result); set.erase(s[left]); left++; //printf(\u0026#34;left = %d\\n\u0026#34;,left); } result = max(result,i-left+1); //这个如果不放出来 那么遇到完全不连续的字符串 // 这个时候要加一是因为这个时候left所在的元素算进了长度之中 // 就会只返回0 set.insert(s[i]); } return result; } }; 438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n这一题就应该写一个数组记录目标子串的个数 然后后面用双指针移动 遇到就相减 一旦次数负一就说明最左边的不符合要求 那么要还原原本计数的这个数组 并移动最左指针 判断最终条件就是数组长度和目标子串长度相等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { vector\u0026lt;int\u0026gt;result; if(s.size() \u0026lt; p.size())return result; vector\u0026lt;int\u0026gt;pCounter(26,0); for(char c : p){ pCounter[c-\u0026#39;a\u0026#39;]++; } int left = 0; int right = 0; for(right = 0;right \u0026lt; s.size();right++){ pCounter[s[right]-\u0026#39;a\u0026#39;]--; while(pCounter[s[right]-\u0026#39;a\u0026#39;] \u0026lt; 0){ pCounter[s[left]-\u0026#39;a\u0026#39;]++; //这就说明应该移动最左边的 left++; } if(right - left + 1 == p.size())result.push_back(left); } return result; } }; 回溯 46. 全排列 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: void backtracing(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;result,vector\u0026lt;int\u0026gt;\u0026amp;nums,vector\u0026lt;int\u0026gt;\u0026amp;path,int depth,vector\u0026lt;bool\u0026gt;\u0026amp;judge){ if(depth == nums.size()){ result.push_back(path); return; } for(int i = 0;i \u0026lt; nums.size();i++){ if(judge[i] == true)continue; path.push_back(nums[i]); depth++; judge[i] = true; backtracing(result,nums,path,depth,judge); depth--; path.pop_back(); judge[i] = false; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;result; vector\u0026lt;bool\u0026gt;judge(nums.size(),false); vector\u0026lt;int\u0026gt;path; backtracing(result,nums,path,0,judge); return result; } }; 22. 括号生成 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; ans,string\u0026amp; cur, int open, int close, int n){ if(cur.size() == n * 2){ ans.push_back(cur); return; } if(open \u0026lt; n){ cur.push_back(\u0026#39;(\u0026#39;); backtrack(ans,cur,open+1,close,n); cur.pop_back(); } if(open \u0026gt; close){ cur.push_back(\u0026#39;)\u0026#39;); backtrack(ans,cur,open,close+1,n); cur.pop_back(); } return; } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { string current; vector\u0026lt;string\u0026gt; result; backtrack(result,current,0,0,n); return result; } }; 图论 994. 腐烂的橘子 - 力扣（LeetCode）\n这题用的广搜\n有一个很生动形象的例子 往外一层层扩散腐烂 其实算的就是腐烂的橘子一层层向外扩建 有点类似如何找到两个独立的岛屿\n一层层向外扩建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: struct Index{ int x,y,time; }; int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int n = grid.size(); int m = grid[0].size(); queue\u0026lt;Index\u0026gt;que; int lastTime = 0; //记录最后的时间 int dx[4] = {0,0,-1,1}; int dy[4] = {1,-1,0,0}; for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; m;j++){ if(grid[i][j] == 2) que.push({i,j,0}); } } //在队列遍历过程中 这个橘子应该是所有都能涉及到 //有可能有些橘子不会被传染到 while(que.empty() != true){ //先取出来 然后遍历 Index t = que.front(); que.pop(); lastTime = t.time; for(int i = 0;i \u0026lt; 4;i++){ int new_x = t.x + dx[i]; int new_y = t.y + dy[i]; if(new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; n \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; m \u0026amp;\u0026amp; grid[new_x][new_y] == 1){ grid[new_x][new_y] = 2; que.push({new_x,new_y,t.time+1}); //涉及到多元组 都是用花括号来使用 //当意识到队列中元素过多 可以使用结构体来解决 } } } for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; n;j++){ if(grid[i][j] == 1){ return -1; } } } return lastTime; } }; 79. 单词搜索 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public: void backtrack(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, string word, int x, int y, int count, bool \u0026amp;result) { if (result) return; // 如果找到结果，立即返回 if (visited[x][y] == true || board[x][y] != word[count]) { return; } count++; if (count == word.size()) { result = true; return; } visited[x][y] = true; int dx[4] = {0, 0, -1, 1}; int dy[4] = {1, -1, 0, 0}; for (int i = 0; i \u0026lt; 4; i++) { int new_x = x + dx[i]; int new_y = y + dy[i]; if (new_x \u0026lt; 0 || new_x \u0026gt;= board.size() || new_y \u0026lt; 0 || new_y \u0026gt;= board[0].size()) { continue; } backtrack(board, visited, word, new_x, new_y, count, result); } visited[x][y] = false; // 回溯，取消当前点的访问标记 count--; // 回溯，恢复count } bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { int n = board.size(); int m = board[0].size(); bool result = false; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(m, false)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (board[i][j] == word[0]) { backtrack(board, visited, word, i, j, 0, result); if (result) return true; // 如果找到结果，立即返回 } } } return result; } }; 子串 哈希表+前缀和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int,int\u0026gt;mp; mp[0] = 1; int count = 0; int pre = 0; // pre[i]为0到i所有数的和 那么pre[i]可以有pre[i-1]推出来的 //那么j到I的和就可以转化成pre[i]-pre[j-1] = k //哈希表以和为键值 for(auto \u0026amp; x : nums){ pre += x; //除去判断部分 剩下就是统计了前缀和 //因为 if(mp.find(pre-k) != mp.end()){ count += mp[pre-k]; } mp[pre]++; } return count; } }; 为什么不能使用滑动窗口\n滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点反而要向左移动，导致算法复杂度不是线性的。\n普通数组 56. 合并区间 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { //这道题最重要的点就是 先排序 //排序后依次比较 符合则合并 不符合就丢弃 sort(intervals.begin(),intervals.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;result; for(int i = 0;i \u0026lt; intervals.size();){ int t = intervals[i][1]; int j = i+1; while(j \u0026lt; intervals.size()\u0026amp;\u0026amp;intervals[j][0] \u0026lt;= t){ t = max(t,intervals[j][1]); j++; } result.push_back({intervals[i][0],t}); i = j; } return result; } }; 189. 轮转数组 - 力扣（LeetCode）\n这个说有三种方法 除了第一种过于暴力 我是建议别写\n我学习的是三次翻转\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: void reverse(vector\u0026lt;int\u0026gt;\u0026amp; nums,int start, int end){ while(start \u0026lt; end){ swap(nums[start],nums[end]); start++; end--; } return; } void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k = k % n; reverse(nums,0,n-1); //这个地方越界了 reverse(nums,0,k-1); reverse(nums,k,n-1); } }; 238. 除自身以外数组的乘积 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int length = nums.size(); vector\u0026lt;int\u0026gt;L(length,0); vector\u0026lt;int\u0026gt;R(length,0); vector\u0026lt;int\u0026gt;ans(length,0); L[0] = 1; for(int i = 1;i \u0026lt; nums.size();i++){ L[i] = L[i-1] * nums[i-1]; //printf(\u0026#34;i = %d L[i]=%d\\n\u0026#34;,i,L[i]); } R[length-1] = 1; for(int i = length-2;i \u0026gt;= 0;i--){ R[i] = R[i+1] * nums[i+1]; //printf(\u0026#34;i = %d R[i]=%d\\n\u0026#34;,i,R[i]); } for(int i = 0;i \u0026lt; nums.size();i++){ ans[i] = L[i] * R[i]; //printf(\u0026#34;ans = %d\\n\u0026#34;,ans[i]); } return ans; } }; 这个思路其实理清楚了 很简单 因为只能有一次循环 如果我每次统计我所在位置的左侧数组的乘积 在统计我右侧所有数组的乘积 那么是否就能得出和 这样子肯定是可以的\n矩阵 73. 矩阵置零 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); bool flag_col0 = false; bool flag_row0 = false; for(int i = 0;i \u0026lt; n;i++){ if(matrix[i][0] == 0)flag_col0 = true; } for(int i = 0;i \u0026lt; m;i++){ if(matrix[0][i] == 0)flag_row0 = true; } for(int i = 1;i \u0026lt; n;i++){ for(int j = 1;j \u0026lt; m;j++){ if(matrix[i][j] == 0){ matrix[i][0] = matrix[0][j] = 0; } } } for(int i = 1;i \u0026lt; n;i++){ for(int j = 1;j \u0026lt; m;j++){ if(matrix[i][0] == 0 || matrix[0][j] == 0){ matrix[i][j] = 0; } } } if(flag_col0 == true){ for(int i = 0;i \u0026lt; n;i++){ matrix[i][0] = 0; } } if(flag_row0 == true){ for(int j = 0;j \u0026lt; m;j++){ matrix[0][j] = 0; } } } }; 54. 螺旋矩阵 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { vector\u0026lt;int\u0026gt; result; int u = 0; int d = matrix.size()-1; int l = 0; int r = matrix[0].size()-1; while (true) { for (int i = l; i \u0026lt;= r; ++i) result.push_back(matrix[u][i]); if (++u \u0026gt; d) break; for (int i = u; i \u0026lt;= d; ++i) result.push_back(matrix[i][r]); if (--r \u0026lt; l) break; for (int i = r; i \u0026gt;= l; --i) result.push_back(matrix[d][i]); if (--d \u0026lt; u) break; for (int i = d; i \u0026gt;= u; --i) result.push_back(matrix[i][l]); if (++l \u0026gt; r) break; } return result; } }; 48. 旋转图像 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); auto matrix_new = matrix; for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; m;j++){ matrix_new[j][n-i-1] = matrix[i][j]; } } matrix = matrix_new; return; } }; 这个实在也不大理解这个原地旋转的方法 只能采取这种复制的办法 事实上我觉得矩阵可以简单粗暴采取这种复制变换的方法\n240. 搜索二维矩阵 II - 力扣（LeetCode）\n从右上角搜索\n话说这个为啥快我也想不明白O(M+N)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { //更好的方法 从右上角开始找这个数字 int m = matrix.size(); int n = matrix[0].size(); int x = 0; int y = n-1; while(x \u0026lt; m \u0026amp;\u0026amp; y \u0026gt;= 0){ if(matrix[x][y] == target) return true; if(matrix[x][y] \u0026gt; target){ --y; } else //else 保证条件一定是互斥的 ++x; } return false; } }; 链表 160. 相交链表 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA == NULL || headB == NULL)return 0; ListNode * pA = headA; ListNode * pB = headB; while(pA != pB){ if(pA == NULL)pA = headB; else pA = pA-\u0026gt;next; if(pB == NULL)pB = headA; else pB = pB-\u0026gt;next; } return pA; } }; 就是为空则交换 直到二者相遇或都指向空\n234. 回文链表 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { int n = 0; ListNode * newHead = new ListNode(0,head); newHead-\u0026gt;next = NULL; ListNode * fast = head; ListNode * slow = head; while(fast != NULL){ n++; fast = fast-\u0026gt;next; } fast = head; for(int i = 0;i \u0026lt; n/2;i++) slow = slow-\u0026gt;next; //指向后半截的开头 //逆转前半截的链表 if(n % 2 == 1)slow = slow-\u0026gt;next; for(int i = 0;i \u0026lt; n / 2;i++){ ListNode * temp = fast-\u0026gt;next; //现存你的下一位 fast-\u0026gt;next = newHead-\u0026gt;next; newHead-\u0026gt;next = fast; fast = temp; } int mid = n/2; ListNode *index = newHead-\u0026gt;next; while(mid--){ if(index-\u0026gt;val != slow-\u0026gt;val)return false; index = index-\u0026gt;next; slow = slow-\u0026gt;next; } return true; } }; 初始化：\nnewHead 初始化为一个值为 0 的哑节点。 fast 和 slow 都指向链表的头节点，值为 1。 找到链表中点：\n1 2 3 4 cpp复制代码while(fast != NULL){ n++; fast = fast-\u0026gt;next; } 使用 fast 指针遍历链表以计算节点数 n。对于我们的示例链表，n = 5。 然后将 fast 重置回 head。 移动 slow 到链表的中间位置：\n1 2 3 cpp复制代码for(int i = 0; i \u0026lt; n/2; i++) slow = slow-\u0026gt;next; if(n % 2 == 1) slow = slow-\u0026gt;next; 对于长度为 5 的链表，中间节点在第 3 个节点。slow 最终会指向值为 3 的节点。 逆转链表前半部分：\n1 2 3 4 5 6 cpp复制代码for(int i = 0; i \u0026lt; n / 2; i++) { ListNode * temp = p-\u0026gt;next; p-\u0026gt;next = newHead-\u0026gt;next; newHead-\u0026gt;next = p; p = temp; } 我们将链表前半部分逆转并连接到 newHead 后面。\n具体步骤如下：\n初始状态：\n1 2 3 rust复制代码链表: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 newHead: 0 p: 指向 1 第一步：\n1 2 3 4 5 6 7 rust复制代码temp: 指向 2 p-\u0026gt;next: 指向 newHead-\u0026gt;next (NULL) newHead-\u0026gt;next: 指向 p (1) p: 指向 temp (2) 链表: 1 -\u0026gt; NULL 2 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 newHead: 0 -\u0026gt; 1 第二步：\n1 2 3 4 5 6 7 rust复制代码temp: 指向 3 p-\u0026gt;next: 指向 newHead-\u0026gt;next (1) newHead-\u0026gt;next: 指向 p (2) p: 指向 temp (3) 链表: 2 -\u0026gt; 1 -\u0026gt; NULL 3 -\u0026gt; 2 -\u0026gt; 1 newHead: 0 -\u0026gt; 2 -\u0026gt; 1 比较逆转后的前半部分和后半部分：\n1 2 3 4 5 6 7 cpp复制代码ListNode *index = newHead-\u0026gt;next; while(mid--){ if(index-\u0026gt;val != slow-\u0026gt;val) return false; index = index-\u0026gt;next; slow = slow-\u0026gt;next; } return true; index 指针指向逆转后的前半部分（即 newHead-\u0026gt;next）。 slow 指向链表的后半部分。 逐个节点进行比较，如果所有值都相等，则链表是回文的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: bool hasCycle(ListNode *head) { if(head == NULL ||head-\u0026gt;next == NULL)return false; //这两个地方都是犯了同样的错误 ListNode * slow = head; ListNode * fast = head-\u0026gt;next; while(true){ if(fast == NULL || fast-\u0026gt;next == NULL)return false; //要先判断是否是空指针 否则力扣直接就报错了 fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if(slow == fast) break; } return true; } }; 存疑：如何写环形链表的测试案例呢： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 int main() { Solution solution; // Test case 1: Empty list ListNode *test1 = NULL; printResult(solution.hasCycle(test1), false); // Test case 2: Single node without cycle ListNode *test2 = new ListNode(1); printResult(solution.hasCycle(test2), false); delete test2; // Test case 3: Single node with cycle ListNode *test3 = new ListNode(1); test3-\u0026gt;next = test3; printResult(solution.hasCycle(test3), true); test3-\u0026gt;next = NULL; // Break the cycle for cleanup delete test3; // Test case 4: Multiple nodes without cycle ListNode *test4_1 = new ListNode(1); ListNode *test4_2 = new ListNode(2); ListNode *test4_3 = new ListNode(3); test4_1-\u0026gt;next = test4_2; test4_2-\u0026gt;next = test4_3; printResult(solution.hasCycle(test4_1), false); delete test4_3; delete test4_2; delete test4_1; // Test case 5: Multiple nodes with cycle ListNode *test5_1 = new ListNode(1); ListNode *test5_2 = new ListNode(2); ListNode *test5_3 = new ListNode(3); ListNode *test5_4 = new ListNode(4); test5_1-\u0026gt;next = test5_2; test5_2-\u0026gt;next = test5_3; test5_3-\u0026gt;next = test5_4; test5_4-\u0026gt;next = test5_2; // Creating a cycle here printResult(solution.hasCycle(test5_1), true); // Clean up to avoid memory leaks (breaking the cycle first) test5_4-\u0026gt;next = NULL; delete test5_4; delete test5_3; delete test5_2; delete test5_1; return 0; } 24. 两两交换链表中的节点 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode * virtual_head = new ListNode(0); virtual_head-\u0026gt;next = head; ListNode * tmp = virtual_head; while(tmp-\u0026gt;next != NULL \u0026amp;\u0026amp; tmp-\u0026gt;next-\u0026gt;next != NULL){ ListNode * p1 = tmp-\u0026gt;next; ListNode * p2 = tmp-\u0026gt;next-\u0026gt;next; tmp-\u0026gt;next = tmp-\u0026gt;next-\u0026gt;next; p1-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p1; tmp = tmp-\u0026gt;next-\u0026gt;next; } return virtual_head-\u0026gt;next; } }; 19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode * temp = head; if(n == 1 \u0026amp;\u0026amp; head-\u0026gt;next == NULL)return NULL; int length = 1; while(temp-\u0026gt;next){ //这里出错哈 temp = temp-\u0026gt;next; length++; } int num = length - n; ListNode * virtual_head = new ListNode(0); virtual_head-\u0026gt;next = head; ListNode * temp1 = virtual_head; ListNode * temp2 = head; while(num--){ temp1 = temp1-\u0026gt;next; temp2 = temp2-\u0026gt;next; } temp1-\u0026gt;next = temp2-\u0026gt;next; return virtual_head-\u0026gt;next; } }; 21. 合并两个有序链表 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { //谁为空就返回另一个 二者小的连接下一个 if(list1 == NULL)return list2; else if(list2 == NULL)return list1; else if(list1-\u0026gt;val \u0026lt; list2-\u0026gt;val){ list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next,list2); return list1; } else{ list2-\u0026gt;next = mergeTwoLists(list2-\u0026gt;next,list1); return list2; } } }; 148. 排序链表 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { return sortList(head,NULL); } ListNode* sortList(ListNode* head,ListNode* tail) { if(head == NULL){ return head; } if(head-\u0026gt;next == tail){ head-\u0026gt;next = NULL; return head; } //当链表节点个数小于或等于1 终止对链表的拆分 ListNode * slow = head; ListNode * fast = head; while(fast != tail){ slow = slow-\u0026gt;next; fast = fast-\u0026gt;next; if(fast != tail){ fast = fast-\u0026gt;next; } } ListNode * mid = slow; return merge(sortList(head,mid),sortList(mid,tail)); } //所以返回的其实有两个链表 //这个函数合并两个有序链表 就是比较两个原来有序链表 较小的值插入头 ListNode * merge(ListNode * head1, ListNode * head2){ ListNode * dummyhead = new ListNode(0); ListNode * temp = dummyhead,* temp1 = head1,*temp2 = head2; while(temp1 != NULL \u0026amp;\u0026amp; temp2 != NULL){ if(temp1-\u0026gt;val \u0026lt;= temp2-\u0026gt;val){ temp-\u0026gt;next = temp1; temp1 = temp1-\u0026gt;next; } else{ temp-\u0026gt;next = temp2; temp2 = temp2-\u0026gt;next; } temp = temp-\u0026gt;next; } //这个是一长一短 if(temp1 != NULL){ temp-\u0026gt;next = temp1; } else if(temp2 != NULL){ temp-\u0026gt;next = temp2; } return dummyhead-\u0026gt;next; } }; 138. 随机链表的复制 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: unordered_map\u0026lt;Node*, Node*\u0026gt; cachedNode; Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } //如果这个节点不存在的话 if (!cachedNode.count(head)) { Node* headNew = new Node(head-\u0026gt;val); cachedNode[head] = headNew; headNew-\u0026gt;next = copyRandomList(head-\u0026gt;next); headNew-\u0026gt;random = copyRandomList(head-\u0026gt;random); } return cachedNode[head]; } }; 二叉树 94. 二叉树的中序遍历 - 力扣（LeetCode）\n104. 二叉树的最大深度 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int depth(TreeNode * root){ if(root == NULL)return NULL; int left_height = depth(root-\u0026gt;left); int right_height = depth(root-\u0026gt;right); int depth = max(left_height,right_height)+1; return depth; } int maxDepth(TreeNode* root) { return depth(root); } }; 226. 翻转二叉树 - 力扣（LeetCode）\n翻转每一刻树 用先跟遍历\n543. 二叉树的直径 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { int ans; int depth(TreeNode * root){ if(root == NULL){ return 0; } //每一层分别计算自己左子树的高度 和右子树的高度 //得出自己左右最长的高度 也就是路径 int l = depth(root-\u0026gt;left); int r = depth(root-\u0026gt;right); ans = max(ans,l+r+1); return max(l,r)+1; } public: int diameterOfBinaryTree(TreeNode* root) { ans = 1; depth(root); return ans-1; } }; 101. 对称二叉树 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { return judge(root-\u0026gt;left,root-\u0026gt;right); } private: bool judge(TreeNode * node_left,TreeNode * node_right){ if(node_left == NULL \u0026amp;\u0026amp; node_right == NULL)return true; if(node_left == NULL || node_right == NULL || node_left-\u0026gt;val != node_right-\u0026gt;val)return false; return judge(node_left-\u0026gt;left,node_right-\u0026gt;right) \u0026amp;\u0026amp; judge(node_left-\u0026gt;right,node_right-\u0026gt;left); } }; //其实就是遍历到叶子节点 只要叶子节点左右都为空且没有因为值不相同被返回false 108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）\n每次选择中间的数作为根节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: TreeNode* equal(vector\u0026lt;int\u0026gt;\u0026amp; nums,int left, int right){ if(left \u0026gt; right)return NULL; int mid = (left + right+1)/2; TreeNode * root = new TreeNode(nums[mid]); root-\u0026gt;left = equal(nums,left,mid-1); root-\u0026gt;right = equal(nums,mid+1,right); return root; } TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return equal(nums,0,nums.size()-1); } }; 105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* travel(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder){ if(preorder.size() == 0)return NULL; TreeNode * head = new TreeNode(preorder[0]); if(preorder.size() == 1)return head; int divided_position,i; for(i = 0;i \u0026lt; inorder.size();i++){ if(head-\u0026gt;val == inorder[i])break; } divided_position = i; vector\u0026lt;int\u0026gt;new_inorder_left(inorder.begin(),inorder.begin()+divided_position); vector\u0026lt;int\u0026gt;new_inorder_right(inorder.begin()+divided_position+1,inorder.end()); // for(auto i : new_inorder_left){ // cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;\u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // } // for(auto i : new_inorder_right){ // cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34;\u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // } preorder.erase(preorder.begin()); vector\u0026lt;int\u0026gt;new_preorder_left(preorder.begin(),preorder.begin()+new_inorder_left.size()); vector\u0026lt;int\u0026gt;new_preorder_right(preorder.begin()+new_inorder_left.size(),preorder.end()); // for(auto i : new_preorder_left){ // cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;\u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // } // for(auto i : new_preorder_right){ // cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34;\u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // } head-\u0026gt;left = travel(new_preorder_left,new_inorder_left); head-\u0026gt;right = travel(new_preorder_right,new_inorder_right); return head; } TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { if(preorder.size() == 0 || inorder.size() == 0)return NULL; return travel(preorder,inorder); } }; 102. 二叉树的层序遍历 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode *\u0026gt;que; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; if(root == NULL)return result; else que.push(root); while(que.empty() == false){ int length = que.size(); vector\u0026lt;int\u0026gt;path; while(length--){ TreeNode * cur = NULL; cur = que.front(); que.pop(); path.push_back(cur-\u0026gt;val); if(cur-\u0026gt;left != NULL)que.push(cur-\u0026gt;left); if(cur-\u0026gt;right != NULL)que.push(cur-\u0026gt;right); //出错调试点看一下这个有没有传入右子树 } result.push_back(path); } return result; } }; 2. 两数相加 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *dummyHead = new ListNode(0); // 创建一个哑节点作为结果链表的头节点 ListNode *current = dummyHead; // 这个节点用于构建结果链表 int carry = 0; // 进位初始化为0 while (l1 != nullptr || l2 != nullptr || carry != 0) { int sum = carry; // 每次循环开始时，sum初始为上一次的进位 if (l1 != nullptr) { sum += l1-\u0026gt;val; // 如果l1还有节点，加上l1的当前节点值 l1 = l1-\u0026gt;next; // l1移动到下一个节点 } if (l2 != nullptr) { sum += l2-\u0026gt;val; // 如果l2还有节点，加上l2的当前节点值 l2 = l2-\u0026gt;next; // l2移动到下一个节点 } carry = sum / 10; // 计算新的进位 current-\u0026gt;next = new ListNode(sum % 10); // 创建新节点存储两数之和的个位数 current = current-\u0026gt;next; // 移动到结果链表的下一个位置 } return dummyHead-\u0026gt;next; // 返回哑节点的下一个节点，即结果链表的头节点 } }; 这个是正序的 逆序的在准备百度的时候写的 这里留个坑位\n两数相加2 采用递归到最后一位开始往前相加 98. 验证二叉搜索树 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool backtrack(TreeNode * root, long long lower,long long higher){ if(root == NULL)return true; else{ if(root-\u0026gt;val \u0026lt;= lower || root-\u0026gt;val \u0026gt;= higher)return false; else return backtrack(root-\u0026gt;left,lower,root-\u0026gt;val) \u0026amp;\u0026amp; backtrack(root-\u0026gt;right,root-\u0026gt;val,higher); } } bool isValidBST(TreeNode* root) { return backtrack(root,LONG_MIN,LONG_MAX); } }; 注意递归条件 类似左子树右子树都是这样更新条件的 唯一的问题就是递归出口不是很明显啊\n199. 二叉树的右视图 - 力扣（LeetCode）\n层次遍历 把每个层次遍历的最后一个元素压进去就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; rightSideView(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt;que; if(root != NULL)que.push(root); vector\u0026lt;int\u0026gt;result; while(!que.empty()){ int size = que.size(); vector\u0026lt;int\u0026gt;vec; for(int i = 0;i \u0026lt; size;i++){ TreeNode * node = que.front(); que.pop(); vec.push_back(node-\u0026gt;val); if(node-\u0026gt;left) que.push(node-\u0026gt;left); if(node-\u0026gt;right) que.push(node-\u0026gt;right); } result.push_back(vec[size-1]); }return result; } }; 230. 二叉搜索树中第 K 小的元素 - 力扣（LeetCode）\n直接按照中序就能从小到大排列 然后就知道第k小的元素了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void inorderTree(TreeNode*root,vector\u0026lt;int\u0026gt;\u0026amp;result){ if(root == NULL)return; inorderTree(root-\u0026gt;left,result); result.push_back(root-\u0026gt;val); inorderTree(root-\u0026gt;right,result); } int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt;result; inorderTree(root,result); return result[k-1]; } }; 236. 二叉树的最近公共祖先 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* dfs(TreeNode * node,TreeNode * p, TreeNode * q){ if(node == NULL)return NULL; if(node == p || node == q)return node; TreeNode * left = dfs(node-\u0026gt;left,p,q); TreeNode *right = dfs(node-\u0026gt;right,p,q); if(left != NULL \u0026amp;\u0026amp; right != NULL)return node; else if(left != NULL)return left; else return right; } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL)return NULL; TreeNode *result = dfs(root,p,q); return result; } }; 437. 路径总和 III - 力扣（LeetCode）\n前缀和+哈希表\n记录根节点到目前节点的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode * root,int targetSum,long long currentsum,int \u0026amp;ans,unordered_map\u0026lt;long long,int\u0026gt; \u0026amp;prefix){ if(root == NULL)return; currentsum += root-\u0026gt;val; //cout\u0026lt;\u0026lt;currentsum\u0026lt;\u0026lt;endl; if(prefix.find(currentsum-targetSum) != prefix.end()){ //找到了 //cout\u0026lt;\u0026lt;prefix[currentsum]; ans+=prefix[currentsum-targetSum]; } prefix[currentsum]++; dfs(root-\u0026gt;left,targetSum,currentsum,ans,prefix); dfs(root-\u0026gt;right,targetSum,currentsum,ans,prefix); prefix[currentsum]--; return; } int pathSum(TreeNode* root, int targetSum) { int ans = 0; unordered_map\u0026lt;long long,int\u0026gt;prefix{{0,1}}; dfs(root,targetSum,0,ans,prefix); return ans; } }; 二分查找 35. 搜索插入位置 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left \u0026lt;= right){ //要写等号 int mid = left + (right-left) /2; if(nums[mid] == target) return mid; else if(nums[mid] \u0026gt; target)right = mid-1; else left = mid+1; } // return left; } }; 74. 搜索二维矩阵 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int i = 0; int j = n-1; while(true){ if(i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;=n)break; if(matrix[i][j] == target) return true; else if(matrix[i][j] \u0026gt; target){ j--; } else i++; } return false; } }; 栈 739. 每日温度 - 力扣（LeetCode）\n我认为这个目前最好感觉 没必要用什么单调栈\n直接从后往前进行更新 既然你想找右边最高温度\n那就从右往左不断更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { int n = temperatures.size(); vector\u0026lt;int\u0026gt;result(n,0); result[n - 1] = 0; for (int i = n - 2; i \u0026gt;= 0; i--) { int j = i + 1; while (temperatures[j] \u0026lt;= temperatures[i] \u0026amp;\u0026amp; result[j] != 0) { j += result[j]; } if (temperatures[j] \u0026gt; temperatures[i]) { result[i] = j - i; } else result[i] = 0; } return result; } }; 堆 347. 前 K 个高频元素 - 力扣（LeetCode）\n215. 数组中的第K个最大元素 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { priority_queue\u0026lt;int\u0026gt;q(nums.begin(),nums.end()); int result; while(--k){ q.pop(); } return q.top(); } }; 贪心算法 121. 买卖股票的最佳时机 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int minprice = INT_MAX; int maxprofit = 0; for(int i = 0;i \u0026lt; prices.size();i++){ if(minprice \u0026gt; prices[i])minprice = prices[i]; else if(maxprofit \u0026lt; prices[i] - minprice)maxprofit = prices[i] - minprice; } return maxprofit; } }; 55. 跳跃游戏 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cover = 0; // 覆盖范围 if(nums.size() == 1)return true; // 指示指针只能在cover的范围中移动 for(int i = 0;i \u0026lt;= cover;i++){ cover = max(cover,nums[i]+i); if(cover \u0026gt;= nums.size() -1)return true; } return false; } }; 动态规划 118. 杨辉三角 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generate(int numRows) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result(numRows); for(int i = 0;i \u0026lt; numRows;i++){ result[i].resize(i+1); result[i][0] =1; result[i][i] = 1; for(int j = 1;j \u0026lt; i;j++){ result[i][j] = result[i-1][j] + result[i-1][j-1]; } } return result; } }; 198. 打家劫舍 - 力扣（LeetCode）\n动态规划最重要就是讲究一个状态转移 怎么转移 如何得出公式\n有点类似于数学归纳法 因为n=1什么情况 所以推出n = N什么情况\n比如打家劫舍 相邻不可以的话 那就是自己这个房子加上跟自己隔的房子和不选自己房子打劫的金额进行比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int length = nums.size(); vector\u0026lt;int\u0026gt;dp = vector\u0026lt;int\u0026gt;(length,0); int max_num = 0; if(nums.size() == 1)return nums[0]; else if(nums.size() == 2)return max(nums[0],nums[1]); else{ dp[0] = nums[0]; dp[1] = max(nums[0],nums[1]); //printf(\u0026#34;%d\\n\u0026#34;,dp[1]); for(int i = 2;i \u0026lt; length;++i){ dp[i] = max(nums[i] + dp[i-2],dp[i-1]); //printf(\u0026#34;-%d\\n\u0026#34;,max_num); } } return dp[length-1]; } }; ","date":"2025-02-15T17:39:44+08:00","permalink":"https://paipai2001.github.io/p/hot100/","title":"hot100"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://paipai2001.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://paipai2001.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://paipai2001.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://paipai2001.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://paipai2001.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://paipai2001.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://paipai2001.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://paipai2001.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://paipai2001.github.io/p/emoji-support/","title":"Emoji Support"},{"content":"刷题记录 1 数组 704. 二分查找 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size()-1; while (left \u0026lt;= right){ int mid = (left +right) /2; if(target \u0026lt; nums[mid]) right = mid-1; if(target \u0026gt; nums[mid]) left = mid+1; if(target == nums[mid])return mid; } return -1; } }; mid不是要返回的结果 所以要对应进行+1和-1\n27. 移除元素 - 力扣（LeetCode）\n其实是刷新数组 不断反复刷新数组 就是一个是新的生成数组的指针 一个是旧的数组 旧的数组指针用来判断 新的用来更新\n977. 有序数组的平方 - 力扣（LeetCode）\n前后两个指针比较 较大的先入列 但这是必须建立在数组有序的前提下\n还有就是指针越界的问题 k != 0是错误的 往前一位就对了 因为使用了k\u0026ndash; 必须到0这个数字也判断完后才叫做完整结束\n209. 长度最小的子数组 - 力扣（LeetCode）\n我本来以为要用两个循环写的 后面忽然意识到 左边起始指针的移动 是可以通过最外层的循环一层层往右 如果不符和大于等于目标值这个条件 就会再次进入到内循环 只要明白了这一点其实就不难了\n59. 螺旋矩阵 II - 力扣（LeetCode）\n2 链表 203. 移除链表元素 - 力扣（LeetCode）\n指针越界了 应该是这个问题\n此处保留一下随想录的参考答案：\n206. 反转链表 - 力扣（LeetCode）\n24. 两两交换链表中的节点 - 力扣（LeetCode）\n19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）\n面试题 02.07. 链表相交 - 力扣（LeetCode）\n142. 环形链表 II - 力扣（LeetCode）\n数学公式的解释：\n环找到了 那入口呢？\n2. 两数相加 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int length1 = 1; int length2 = 1; ListNode * temp1 = l1; ListNode * temp2 = l2; while(temp1-\u0026gt;next != NULL){ length1++; temp1 = temp1-\u0026gt;next; } while(temp2-\u0026gt;next != NULL){ length2++; temp2 = temp2-\u0026gt;next; } temp1 = l1; temp2 = l2; int index = 0; if(length1 \u0026gt; length2){ while(temp2 != NULL){ temp1-\u0026gt;val = temp1-\u0026gt;val + temp2-\u0026gt;val; if(index == 1)temp1-\u0026gt;val +=1; if(temp1-\u0026gt;val \u0026gt;= 10){ temp1-\u0026gt;val = temp1-\u0026gt;val % 10; index = 1; } else index = 0; temp1 = temp1-\u0026gt;next; temp2 = temp2-\u0026gt;next; } if(index == 1){ temp1-\u0026gt;val += 1; if(temp1-\u0026gt;val \u0026gt;=10)temp1-\u0026gt;val = temp1-\u0026gt;val % 10; else index = 0; if(temp1-\u0026gt;next == NULL){ if(index == 1){ ListNode * new_node = new ListNode(0); new_node-\u0026gt;val = 1; new_node-\u0026gt;next = NULL; temp1-\u0026gt;next = new_node; } return l1; } temp1 = temp1-\u0026gt;next; while(temp1-\u0026gt;next != NULL){ if(index == 1)temp1-\u0026gt;val += 1; if(temp1-\u0026gt;val \u0026gt;=10)temp1-\u0026gt;val = temp1-\u0026gt;val % 10; else index = 0; temp1 = temp1-\u0026gt;next; } if(index == 1)temp1-\u0026gt;val += 1; if(temp1-\u0026gt;val \u0026gt;= 10){ temp1-\u0026gt;val = temp1-\u0026gt;val % 10; ListNode * new_node = new ListNode(0); new_node-\u0026gt;val = 1; new_node-\u0026gt;next = NULL; temp1-\u0026gt;next = new_node; } } return l1; } else if(length1 == length2){ while(temp1 != NULL){ temp1-\u0026gt;val = temp1-\u0026gt;val + temp2-\u0026gt;val; if(index == 1)temp1-\u0026gt;val +=1; if(temp1-\u0026gt;val \u0026gt;= 10){ temp1-\u0026gt;val = temp1-\u0026gt;val % 10; index = 1; } else index = 0; temp1 = temp1-\u0026gt;next; temp2 = temp2-\u0026gt;next; } temp1 = l1; while(temp1-\u0026gt;next != NULL)temp1 = temp1-\u0026gt;next; if(index == 1){ ListNode * new_node = new ListNode(0); new_node-\u0026gt;val = 1; new_node-\u0026gt;next = NULL; temp1-\u0026gt;next = new_node; } return l1; } else{ while(temp1 != NULL){ temp2-\u0026gt;val = temp1-\u0026gt;val + temp2-\u0026gt;val; if(index == 1)temp2-\u0026gt;val +=1; if(temp2-\u0026gt;val \u0026gt;= 10){ temp2-\u0026gt;val = temp2-\u0026gt;val % 10; index = 1; } else index = 0; temp1 = temp1-\u0026gt;next; temp2 = temp2-\u0026gt;next; } printf(\u0026#34;%d\u0026#34;,temp2-\u0026gt;val); if(index == 1){ temp2-\u0026gt;val += 1; //printf(\u0026#34;%d\u0026#34;,temp2-\u0026gt;val); if(temp2-\u0026gt;val \u0026gt;=10)temp2-\u0026gt;val = temp2-\u0026gt;val % 10; else index = 0; //printf(\u0026#34;%d\u0026#34;,temp2-\u0026gt;val); if(temp2-\u0026gt;next == NULL){ if(index == 1){ ListNode * new_node = new ListNode(0); new_node-\u0026gt;val = 1; new_node-\u0026gt;next = NULL; temp2-\u0026gt;next = new_node; } return l2; } temp2 = temp2-\u0026gt;next; if(index == 0)return l2; while(temp2-\u0026gt;next != NULL){ //printf(\u0026#34;index = %d\\n\u0026#34;,index); if(index == 1)temp2-\u0026gt;val += 1; if(temp2-\u0026gt;val \u0026gt;=10){ temp2-\u0026gt;val = temp2-\u0026gt;val % 10; index = 1; } else index = 0; //printf(\u0026#34;index = %d\\n\u0026#34;,index); temp2 = temp2-\u0026gt;next; } if(index == 1)temp2-\u0026gt;val += 1; else index = 0; //temp2 = temp2-\u0026gt;next; if(temp2-\u0026gt;val \u0026gt;= 10){ temp2-\u0026gt;val = temp2-\u0026gt;val % 10; ListNode * new_node = new ListNode(0); new_node-\u0026gt;val = 1; new_node-\u0026gt;next = NULL; temp2-\u0026gt;next = new_node; } } return l2; } } }; 3 哈希表 242. 有效的字母异位词 - 力扣（LeetCode）\n注解：增强循环这个知识点\nunordered_set nums_set(nums1.begin(),nums1.end())\n349. 两个数组的交集 - 力扣（LeetCode）\n心得：感觉目前没有很明白什么时候用哈希表啊\n202. 快乐数 - 力扣（LeetCode）\n1. 两数之和 - 力扣（LeetCode）\n这道题注意点：\n不可以键值相反 会查找不到 明白谁才是索引\n注意返回一组数据可以使用{}\n4 字符串 344. 反转字符串 - 力扣（LeetCode）\n这题没啥好说的 其实这个swap我感觉考它的实现会更难一点\n541. 反转字符串 II - 力扣（LeetCode）\n代码随想录 (programmercarl.com)\n151. 反转字符串中的单词 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: void reverseString(string \u0026amp;s, int start, int end){ // for(int i = start,j = end;i \u0026lt; j;i++,j--) swap(s[i],s[j]); } void removeSpace(string \u0026amp;s){ int slow = 0; for(int i = 0;i \u0026lt; s.size();i++){ if(s[i] != \u0026#39; \u0026#39;){ if(slow != 0)s[slow++] = \u0026#39; \u0026#39;; // 手动控制空格 遇到非空空格开始处理 // slow表示的是处理后的大小 那么思考什么才是符合处理后的 就是单词和单词之间的空格 // 前面的肯定略掉了 需要处理的 单词之间多余的空格 和单词最后的空格 // 单词最后的空格进不了条件语句 // 所以处理的是单词中间多余的空格 // 所以就是单词一步一步前进 // 手动控制空格的个数 只要slow不为0 说明这个不是第一个单词 那么就可以控制它保留一个空格 while(i \u0026lt; s.size()\u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39;){ s[slow++] =s[i++]; // 一旦出现空格则跳出循环语句 重新进入上一层循环 产生一个空格则继续进入单词的输入 } } } s.resize(slow);//slow大小即为去除多余空格的大小 } string reverseWords(string s) { removeSpace(s); reverseString(s,0,s.size()-1); // printf(\u0026#34;s=%s\u0026#34;,s.c_str()); int start = 0, end = s.size()-1; for(int i = 0;i \u0026lt;= s.size();++i){ // printf(\u0026#34;%d\u0026#34;,s.size()-1); // 这么多打印 只为了找到正确的位置 后面才发现我真的脑袋给门夹了 // 只要碰到空格就反转就可以了 何必去绕远路呢 if(s[i] == \u0026#39; \u0026#39; || i == s.size()){ // printf(\u0026#34;start=%d\\n\u0026#34;,start); reverseString(s,start,i-1); // start要移动到单词的第一位 且不改变i这个指针的位置 start = i+1; } } return s; } }; 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）\n459. 重复的子字符串 - 力扣（LeetCode）\n5 双指针 6 栈和队列 232. 用栈实现队列 - 力扣（LeetCode）\n225. 用队列实现栈 - 力扣（LeetCode）\n20. 有效的括号 - 力扣（LeetCode）\n1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）\n150. 逆波兰表达式求值 - 力扣（LeetCode）\n239. 滑动窗口最大值 - 力扣（LeetCode）\n347. 前 K 个高频元素 - 力扣（LeetCode）\n关于大小顶堆 我这里没有继续细说\nC++ STL | GXBLOGS\n【C++ unordered_map】leetcode常用的哈希表操作_unordered_map-CSDN博客\n7 二叉树 144. 二叉树的前序遍历 - 力扣（LeetCode）\n145. 二叉树的后序遍历 - 力扣（LeetCode）\n94. 二叉树的中序遍历 - 力扣（LeetCode）\n102. 二叉树的层序遍历 - 力扣（LeetCode）\n107. 二叉树的层序遍历 II - 力扣（LeetCode）\n倒转上面的数组即可\n199. 二叉树的右视图 - 力扣（LeetCode）\n每次返回vec最右侧即可\n429. N 叉树的层序遍历 - 力扣（LeetCode）\n节点由两个变成一个数组 记得更改\n116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）\n104. 二叉树的最大深度 - 力扣（LeetCode） 先求左边递归\n然后求右边递归\n然后看左右谁会最大 返回深度\n111. 二叉树的最小深度 - 力扣（LeetCode）\n226. 翻转二叉树 - 力扣（LeetCode）\n前序遍历 然后注意 只有中序遍历不可以 会翻转二叉树两次：\n因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。\n222. 完全二叉树的节点个数 - 力扣（LeetCode）\n与上面的最大深度联系在一块：\n110. 平衡二叉树 - 力扣（LeetCode）\n简单来说在这题计算的是高度 所以我先计算左边的高度 如果一旦检测出高度为负数那么就是不符合平衡树了\n否则就是返回两边树的最大高度 就是当前节点为根节点的树的最大高度\n257. 二叉树的所有路径 - 力扣（LeetCode）\n递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。\n所以递归前要加上判断语句，下面要递归的节点是否为空，如下\n1 2 3 4 5 6 if (cur-\u0026gt;left) { traversal(cur-\u0026gt;left, path, result); } if (cur-\u0026gt;right) { traversal(cur-\u0026gt;right, path, result); } 此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。\n那么回溯要怎么回溯呢，一些同学会这么写，如下：\n1 2 3 4 5 6 7 if (cur-\u0026gt;left) { traversal(cur-\u0026gt;left, path, result); } if (cur-\u0026gt;right) { traversal(cur-\u0026gt;right, path, result); } path.pop_back(); 这个回溯就有很大的问题，我们知道，回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。\n所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！\n404. 左叶子之和 - 力扣（LeetCode）\n513. 找树左下角的值 - 力扣（LeetCode）\n112. 路径总和 - 力扣（LeetCode）\n106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode） 654. 最大二叉树 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int index(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int max = 0; int max_index = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { if (max \u0026lt; nums[i]) { max = nums[i]; max_index = i; } } return max_index; } TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { TreeNode* node = new TreeNode(0); if (nums.size() == 1) { node-\u0026gt;val = nums[0]; return node; } int top = index(nums); node-\u0026gt;val = nums[top]; if (top \u0026gt; 0) { vector\u0026lt;int\u0026gt; left(nums.begin(), nums.begin() + top); node-\u0026gt;left = constructMaximumBinaryTree(left); } if (top \u0026lt; nums.size() - 1) { vector\u0026lt;int\u0026gt; right(nums.begin() + top + 1, nums.end()); node-\u0026gt;right = constructMaximumBinaryTree(right); } return node; } }; 617. 合并二叉树 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1 == NULL)return root2; if(root2 == NULL)return root1; root1-\u0026gt;val += root2-\u0026gt;val; root1-\u0026gt;left = mergeTrees(root1-\u0026gt;left,root2-\u0026gt;left); root1-\u0026gt;right = mergeTrees(root1-\u0026gt;right,root2-\u0026gt;right); return root1; } }; 700. 二叉搜索树中的搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == NULL)return NULL; if(val == root-\u0026gt;val)return root; if(val \u0026lt; root-\u0026gt;val){ return searchBST(root-\u0026gt;left,val); } if(val \u0026gt; root-\u0026gt;val){ return searchBST(root-\u0026gt;right,val); } return NULL; } }; 98. 验证二叉搜索树\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool backtrack(TreeNode * root, long long lower,long long higher){ if(root == NULL)return true; else{ if(root-\u0026gt;val \u0026lt;= lower || root-\u0026gt;val \u0026gt;= higher)return false; else return backtrack(root-\u0026gt;left,lower,root-\u0026gt;val) \u0026amp;\u0026amp; backtrack(root-\u0026gt;right,root-\u0026gt;val,higher); } } bool isValidBST(TreeNode* root) { return backtrack(root,LONG_MIN,LONG_MAX); } }; 530. 二叉搜索树的最小绝对差\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { private: int result = INT_MAX; TreeNode * pre = NULL; public: void midtravel(TreeNode * node){ if(node == NULL)return; midtravel(node-\u0026gt;left); if(pre != NULL){ result = min(result,node-\u0026gt;val-pre-\u0026gt;val); } pre = node; midtravel(node-\u0026gt;right); return; } int getMinimumDifference(TreeNode* root) { midtravel(root); return result; } }; 501. 二叉搜索树中的众数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { private: int maxCount = 0; // 最大频率 int count = 0; // 统计频率 TreeNode* pre = NULL; vector\u0026lt;int\u0026gt; result; void searchBST(TreeNode * cur){ if(cur == NULL)return; searchBST(cur-\u0026gt;left); if(pre == NULL) count = 1; else if(pre-\u0026gt;val == cur-\u0026gt;val)count++; else count = 1; pre = cur; if(count == maxCount)result.push_back(cur-\u0026gt;val); if(count \u0026gt; maxCount){ maxCount = count; result.clear(); result.push_back(cur-\u0026gt;val); } searchBST(cur-\u0026gt;right); } public: vector\u0026lt;int\u0026gt; findMode(TreeNode* root) { count = 0; maxCount = 0; pre = NULL; // 记录前一个节点 result.clear(); searchBST(root); return result; } }; 二叉树的最近公共祖先\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: TreeNode* dfs(TreeNode * node,TreeNode * p, TreeNode * q){ if(node == NULL)return NULL; if(node == p || node == q)return node; TreeNode * left = dfs(node-\u0026gt;left,p,q); TreeNode *right = dfs(node-\u0026gt;right,p,q); if(left != NULL \u0026amp;\u0026amp; right != NULL)return node; else if(left != NULL)return left; else return right; } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL)return NULL; TreeNode *result = dfs(root,p,q); return result; } }; 235. 二叉搜索树的最近公共祖先 https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL)return NULL; if(root-\u0026gt;val \u0026gt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026gt; q-\u0026gt;val){ TreeNode * left = lowestCommonAncestor(root-\u0026gt;left,p,q); if(left != NULL)return left; } if(root-\u0026gt;val \u0026lt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt; q-\u0026gt;val){ TreeNode * right = lowestCommonAncestor(root-\u0026gt;right,p,q); if(right != NULL)return right; } return root; } }; 701. 二叉搜索树中的插入操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root == NULL){ TreeNode * node = new TreeNode(val); return node; } if(root-\u0026gt;val \u0026gt; val){ root-\u0026gt;left = insertIntoBST(root-\u0026gt;left,val); } if(root-\u0026gt;val \u0026lt; val){ root-\u0026gt;right = insertIntoBST(root-\u0026gt;right,val); } return root; } }; 删除操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了 if (root-\u0026gt;val == key) { // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { ///! 内存释放 delete root; return nullptr; } // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点 else if (root-\u0026gt;left == nullptr) { auto retNode = root-\u0026gt;right; ///! 内存释放 delete root; return retNode; } // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 else if (root-\u0026gt;right == nullptr) { auto retNode = root-\u0026gt;left; ///! 内存释放 delete root; return retNode; } // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置 // 并返回删除节点右孩子为新的根节点。 else { TreeNode* cur = root-\u0026gt;right; // 找右子树最左面的节点 while(cur-\u0026gt;left != nullptr) { cur = cur-\u0026gt;left; } cur-\u0026gt;left = root-\u0026gt;left; // 把要删除的节点（root）左子树放在cur的左孩子的位置 TreeNode* tmp = root; // 把root节点保存一下，下面来删除 root = root-\u0026gt;right; // 返回旧root的右孩子作为新root delete tmp; // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧） return root; } } if (root-\u0026gt;val \u0026gt; key) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); if (root-\u0026gt;val \u0026lt; key) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); return root; } }; 669. 修剪二叉搜索树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if(root == NULL)return NULL; if(root-\u0026gt;val \u0026lt; low){ TreeNode * right = trimBST(root-\u0026gt;right,low,high); return right; } if(root-\u0026gt;val \u0026gt; high){ TreeNode * left = trimBST(root-\u0026gt;left,low,high); return left; } root-\u0026gt;left = trimBST(root-\u0026gt;left,low,high); root-\u0026gt;right = trimBST(root-\u0026gt;right,low,high); return root; } }; 108. 将有序数组转换为二叉搜索树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: TreeNode* equal(vector\u0026lt;int\u0026gt;\u0026amp; nums,int left, int right){ if(left \u0026gt; right)return NULL; int mid = (left + right+1)/2; TreeNode * root = new TreeNode(nums[mid]); root-\u0026gt;left = equal(nums,left,mid-1); root-\u0026gt;right = equal(nums,mid+1,right); return root; } TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return equal(nums,0,nums.size()-1); } }; 538. 把二叉搜索树转换为累加树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { private: int pre = 0; void travel(TreeNode *cur){ if(cur == nullptr)return; travel(cur-\u0026gt;right); cur-\u0026gt;val += pre; pre = cur-\u0026gt;val; travel(cur-\u0026gt;left); return; } public: TreeNode* convertBST(TreeNode* root) { pre = 0; travel(root); return root; } }; 8 回溯 回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 如何理解回溯法 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！\n因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\n递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。\n这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行\n77. 组合 - 力扣（LeetCode）\n216. 组合总和 III - 力扣（LeetCode）\n17. 电话号码的字母组合 - 力扣（LeetCode）\n数字和字母如何映射 可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 const string letterMap[10] = { \u0026#34;\u0026#34;, // 0 \u0026#34;\u0026#34;, // 1 \u0026#34;abc\u0026#34;, // 2 \u0026#34;def\u0026#34;, // 3 \u0026#34;ghi\u0026#34;, // 4 \u0026#34;jkl\u0026#34;, // 5 \u0026#34;mno\u0026#34;, // 6 \u0026#34;pqrs\u0026#34;, // 7 \u0026#34;tuv\u0026#34;, // 8 \u0026#34;wxyz\u0026#34;, // 9 }; 39. 组合总和 - 力扣（LeetCode）\n40. 组合总和 II - 力扣（LeetCode）\n131. 分割回文串 - 力扣（LeetCode）\n93. 复原 IP 地址 - 力扣（LeetCode）\n78. 子集 - 力扣（LeetCode）\n但是要清楚子集问题和组合问题、分割问题的的区别，子集是收集树形结构中树的所有节点的结果。\n而组合问题、分割问题是收集树形结构中叶子节点的结果。\n90. 子集 II - 力扣（LeetCode）\n在树形结构中，如果把unordered_set uset放在类成员的位置（相当于全局变量），就把树枝的情况都记录了，不是单纯的控制某一节点下的同一层了。\n不要把判断的used放到全局变量 会记录所有的树枝情况\n9 贪心 455. 分发饼干 - 力扣（LeetCode）\n记住：只使用一层循环\n376. 摆动序列 - 力扣（LeetCode）\n53. 最大子数组和 - 力扣（LeetCode）\nint result = INT32_MIN;\n122. 买卖股票的最佳时机 II - 力扣（LeetCode）\n55. 跳跃游戏 - 力扣（LeetCode）\n45. 跳跃游戏 II - 力扣（LeetCode）\n1005. K 次取反后最大化的数组和 - 力扣（LeetCode）\n134. 加油站 - 力扣（LeetCode）\n10 动态规划 对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！\n确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。\n然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。\n如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。\n如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。\n509. 斐波那契数 - 力扣（LeetCode）\n70. 爬楼梯 - 力扣（LeetCode）\n11 单调栈 12 图论 代码框架 正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。\n很多录友对回溯很陌生，建议先看看代码随想录，回溯算法章节 (opens new window)。\n有递归的地方就有回溯，那么回溯在哪里呢？\n就地递归函数的下面，例如如下代码：\n1 2 3 4 5 void dfs(参数) { 处理节点 dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } 可以看到回溯操作就在递归函数的下面，递归和回溯是相辅相成的。\n在讲解二叉树章节 (opens new window)的时候，二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs（广度优先搜索）\n所以dfs，bfs其实是基础搜索算法，也广泛应用与其他数据结构与算法中。\n我们在回顾一下回溯法 (opens new window)的代码框架：\n1 2 3 4 5 6 7 8 9 10 11 void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：\n1 2 3 4 5 6 7 8 9 10 11 12 void dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } } 可以发现dfs的代码框架和回溯算法的代码框架是差不多的。\n797. 所有可能的路径 - 力扣（LeetCode）\n这个是深度搜索的版本：\n200. 岛屿数量 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: void backtrack(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited,string word,int x,int y,int count,bool \u0026amp;result){ if(result)return; if(visited[x][y] == true || board[x][y] != word[count]){ return; } //printf(\u0026#34;-%c\\n\u0026#34;,board[x][y]); count++; //printf(\u0026#34;count = %d\\n\u0026#34;,count); if(count == word.size()){ result = true; return; } visited[x][y] = true; int dx[4] = {0,0,-1,1}; int dy[4] = {1,-1,0,0}; for(int i = 0;i \u0026lt; 4;i++){ int new_x = x + dx[i]; int new_y = y + dy[i]; if(result == true)return; if(new_x \u0026lt; 0 || new_x \u0026gt;= board.size() || new_y \u0026lt; 0 || new_y \u0026gt;= board[0].size()){continue;} //printf(\u0026#34;%c\\n\u0026#34;,board[new_x][new_y]); backtrack(board,visited,word,new_x,new_y,count,result); } visited[x][y] = false; // 回溯，取消当前点的访问标记 count--; // 回溯，恢复count } bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { int n = board.size(); int m = board[0].size(); int count = 0; bool result = false; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n,vector\u0026lt;bool\u0026gt;(m,false)); for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; m;j++){ if(board[i][j] == word[0]){ backtrack(board,visited,word,i,j,0,result); //这个count不能用全局变量 会保存结果 必须使用局部 //只用来找到头部 if(result) return true; } } } return result; } }; BFS:\n695. 岛屿的最大面积 - 力扣（LeetCode）\n每天刷题 一个乱序数组 找到里头出现次数超过数组长度一半的数字\n时间复杂度为n 空间复杂度为1\n就是标记元素 如果后面又出现+1 没出现-1 为0的时候更换标记元素 直到最后返回index\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int find_mid(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int index; int count = 0; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (count \u0026lt;= 0) { index = nums[i]; //cout \u0026lt;\u0026lt; index \u0026lt;\u0026lt; endl; } if (index == nums[i])count++; else count--; if (count \u0026gt;= 0 \u0026amp;\u0026amp; i == nums.size() - 1) { break; } } return index; } int main() { vector\u0026lt;int\u0026gt; nums = {3,3,2,2,2}; int result = find_mid(nums); cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; return 0; } 单例模式线程安全 call once\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: static Singleton\u0026amp; getInstance() { std::call_once(initFlag, []() { instance = new Singleton(); }); return *instance; } private: Singleton() = default; static Singleton* instance; static std::once_flag initFlag; }; Singleton* Singleton::instance = nullptr; std::once_flag Singleton::initFlag; int main() { std::thread t1([]() { Singleton::getInstance(); }); std::thread t2([]() { Singleton::getInstance(); }); t1.join(); t2.join(); return 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://paipai2001.github.io/p/","title":""}]